// Code generated by github.com/alanshaw/dag-json-gen. DO NOT EDIT.

package testing

import (
	"errors"
	"fmt"
	"io"
	"math"
	"sort"

	jsg "github.com/alanshaw/dag-json-gen"
	cid "github.com/ipfs/go-cid"
)

var _ = cid.Undef
var _ = math.E
var _ = sort.Sort
var _ = errors.Is

func (t *SimpleTypeTree) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.Dog (string) (string)
	if len("Dog") > 8192 {
		return fmt.Errorf("String in field \"Dog\" was too long")
	}
	if err := jw.WriteString(string("Dog")); err != nil {
		return fmt.Errorf("\"Dog\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Dog) > 8192 {
		return fmt.Errorf("String in field t.Dog was too long")
	}
	if err := jw.WriteString(string(t.Dog)); err != nil {
		return fmt.Errorf("t.Dog: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Test ([][]uint8) (slice)
	if len("Test") > 8192 {
		return fmt.Errorf("String in field \"Test\" was too long")
	}
	if err := jw.WriteString(string("Test")); err != nil {
		return fmt.Errorf("\"Test\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Test) > 8192 {
		return fmt.Errorf("Slice value in field t.Test was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.Test: %w", err)
	}
	for i, v := range t.Test {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.Test: %w", err)
			}
		}
		if len(v) > 2097152 {
			return fmt.Errorf("Byte array in field v was too long")
		}

		if err := jw.WriteBytes(v); err != nil {
			return fmt.Errorf("v: %w", err)
		}

	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.Test: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Stuff (testing.SimpleTypeTree) (struct)
	if len("Stuff") > 8192 {
		return fmt.Errorf("String in field \"Stuff\" was too long")
	}
	if err := jw.WriteString(string("Stuff")); err != nil {
		return fmt.Errorf("\"Stuff\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if err := t.Stuff.MarshalDagJSON(jw); err != nil {
		return fmt.Errorf("t.Stuff: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Others ([]uint64) (slice)
	if len("Others") > 8192 {
		return fmt.Errorf("String in field \"Others\" was too long")
	}
	if err := jw.WriteString(string("Others")); err != nil {
		return fmt.Errorf("\"Others\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Others) > 8192 {
		return fmt.Errorf("Slice value in field t.Others was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.Others: %w", err)
	}
	for i, v := range t.Others {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.Others: %w", err)
			}
		}

		if err := jw.WriteUint64(uint64(v)); err != nil {
			return fmt.Errorf("v: %w", err)
		}

	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.Others: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Stufff (testing.SimpleTypeTwo) (struct)
	if len("Stufff") > 8192 {
		return fmt.Errorf("String in field \"Stufff\" was too long")
	}
	if err := jw.WriteString(string("Stufff")); err != nil {
		return fmt.Errorf("\"Stufff\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if err := t.Stufff.MarshalDagJSON(jw); err != nil {
		return fmt.Errorf("t.Stufff: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.BoolPtr (bool) (bool)
	if len("BoolPtr") > 8192 {
		return fmt.Errorf("String in field \"BoolPtr\" was too long")
	}
	if err := jw.WriteString(string("BoolPtr")); err != nil {
		return fmt.Errorf("\"BoolPtr\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if t.BoolPtr == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("t.BoolPtr: %w", err)
		}
	} else {
		if err := jw.WriteBool(*t.BoolPtr); err != nil {
			return fmt.Errorf("t.BoolPtr: %w", err)
		}
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.NotPizza (uint64) (uint64)
	if len("NotPizza") > 8192 {
		return fmt.Errorf("String in field \"NotPizza\" was too long")
	}
	if err := jw.WriteString(string("NotPizza")); err != nil {
		return fmt.Errorf("\"NotPizza\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if t.NotPizza == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("t.NotPizza: %w", err)
		}
	} else {
		if err := jw.WriteUint64(uint64(*t.NotPizza)); err != nil {
			return fmt.Errorf("t.NotPizza: %w", err)
		}
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.StringPtr (string) (string)
	if len("StringPtr") > 8192 {
		return fmt.Errorf("String in field \"StringPtr\" was too long")
	}
	if err := jw.WriteString(string("StringPtr")); err != nil {
		return fmt.Errorf("\"StringPtr\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if t.StringPtr == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("t.StringPtr: %w", err)
		}
	} else {
		if len(*t.StringPtr) > 8192 {
			return fmt.Errorf("String in field t.StringPtr was too long")
		}
		if err := jw.WriteString(string(*t.StringPtr)); err != nil {
			return fmt.Errorf("t.StringPtr: %w", err)
		}
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.SixtyThreeBitIntegerWithASignBit (int64) (int64)
	if len("SixtyThreeBitIntegerWithASignBit") > 8192 {
		return fmt.Errorf("String in field \"SixtyThreeBitIntegerWithASignBit\" was too long")
	}
	if err := jw.WriteString(string("SixtyThreeBitIntegerWithASignBit")); err != nil {
		return fmt.Errorf("\"SixtyThreeBitIntegerWithASignBit\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteInt64(int64(t.SixtyThreeBitIntegerWithASignBit)); err != nil {
		return fmt.Errorf("t.SixtyThreeBitIntegerWithASignBit: %w", err)
	}

	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *SimpleTypeTree) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = SimpleTypeTree{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("SimpleTypeTree: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("SimpleTypeTree: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("SimpleTypeTree: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("SimpleTypeTree: string too large")
				}
				return fmt.Errorf("SimpleTypeTree: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("SimpleTypeTree: %w", err)
			}
			switch name {

			// t.Dog (string) (string)
			case "Dog":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Dog: string too long")
						}
						return fmt.Errorf("t.Dog: %w", err)
					}
					t.Dog = string(sval)
				}

				// t.Test ([][]uint8) (slice)
			case "Test":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.Test: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.Test: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.Test: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([][]uint8, 1)

							{
								bval, err := jr.ReadBytes(2097152)
								if err != nil {
									if errors.Is(err, jsg.ErrLimitExceeded) {
										return fmt.Errorf("item[0]: byte array too large")
									}
									return fmt.Errorf("item[0]: %w", err)
								}
								if len(bval) > 0 {
									item[0] = []uint8(bval)
								}
							}

							t.Test = append(t.Test, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.Test: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.Test: slice too large")
							}
						}
					}

				}

				// t.Stuff (testing.SimpleTypeTree) (struct)
			case "Stuff":

				{
					null, err := jr.PeekNull()
					if err != nil {
						return fmt.Errorf("t.Stuff: %w", err)
					}
					if null {
						if err := jr.ReadNull(); err != nil {
							return fmt.Errorf("t.Stuff: %w", err)
						}
					} else {
						t.Stuff = new(SimpleTypeTree)
						if err := t.Stuff.UnmarshalDagJSON(jr); err != nil {
							return fmt.Errorf("unmarshaling t.Stuff pointer: %w", err)
						}
					}
				}

				// t.Others ([]uint64) (slice)
			case "Others":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.Others: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.Others: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.Others: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]uint64, 1)
							{

								nval, err := jr.ReadNumberAsUint64()
								if err != nil {
									return fmt.Errorf("item[0]: %w", err)
								}
								item[0] = uint64(nval)

							}
							t.Others = append(t.Others, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.Others: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.Others: slice too large")
							}
						}
					}

				}

				// t.Stufff (testing.SimpleTypeTwo) (struct)
			case "Stufff":

				{
					null, err := jr.PeekNull()
					if err != nil {
						return fmt.Errorf("t.Stufff: %w", err)
					}
					if null {
						if err := jr.ReadNull(); err != nil {
							return fmt.Errorf("t.Stufff: %w", err)
						}
					} else {
						t.Stufff = new(SimpleTypeTwo)
						if err := t.Stufff.UnmarshalDagJSON(jr); err != nil {
							return fmt.Errorf("unmarshaling t.Stufff pointer: %w", err)
						}
					}
				}

				// t.BoolPtr (bool) (bool)
			case "BoolPtr":
				{
					bval, err := jr.ReadBoolOrNull()
					if err != nil {
						return fmt.Errorf("t.BoolPtr: %w", err)
					}
					if bval != nil {
						t.BoolPtr = bval
					}
				}

				// t.NotPizza (uint64) (uint64)
			case "NotPizza":
				{

					nval, err := jr.ReadNumberAsUint64OrNull()
					if err != nil {
						return fmt.Errorf("t.NotPizza: %w", err)
					}
					if nval != nil {
						typed := uint64(*nval)
						t.NotPizza = &typed
					}

				}

				// t.StringPtr (string) (string)
			case "StringPtr":
				{
					sval, err := jr.ReadStringOrNull(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.StringPtr: string too long")
						}
						return fmt.Errorf("t.StringPtr: %w", err)
					}
					if sval != nil {
						t.StringPtr = (*string)(sval)
					}
				}

				// t.SixtyThreeBitIntegerWithASignBit (int64) (int64)
			case "SixtyThreeBitIntegerWithASignBit":
				{

					nval, err := jr.ReadNumberAsInt64()
					if err != nil {
						return fmt.Errorf("t.SixtyThreeBitIntegerWithASignBit: %w", err)
					}
					t.SixtyThreeBitIntegerWithASignBit = int64(nval)

				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("SimpleTypeTree: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("SimpleTypeTree: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("SimpleTypeTree: map too large")
			}
		}
	}

	return nil
}
func (t *NeedScratchForMap) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}

	// t.Thing (bool) (bool)
	if len("Thing") > 8192 {
		return fmt.Errorf("String in field \"Thing\" was too long")
	}
	if err := jw.WriteString(string("Thing")); err != nil {
		return fmt.Errorf("\"Thing\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if err := jw.WriteBool(t.Thing); err != nil {
		return fmt.Errorf("t.Thing: %w", err)
	}
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *NeedScratchForMap) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = NeedScratchForMap{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("NeedScratchForMap: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("NeedScratchForMap: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("NeedScratchForMap: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("NeedScratchForMap: string too large")
				}
				return fmt.Errorf("NeedScratchForMap: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("NeedScratchForMap: %w", err)
			}
			switch name {

			// t.Thing (bool) (bool)
			case "Thing":
				bval, err := jr.ReadBool()
				if err != nil {
					return fmt.Errorf("t.Thing: %w", err)
				}
				t.Thing = bval
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("NeedScratchForMap: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("NeedScratchForMap: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("NeedScratchForMap: map too large")
			}
		}
	}

	return nil
}
func (t *SimpleStructV1) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.OldMap (map[string]testing.SimpleTypeOne) (map)
	if len("OldMap") > 8192 {
		return fmt.Errorf("String in field \"OldMap\" was too long")
	}
	if err := jw.WriteString(string("OldMap")); err != nil {
		return fmt.Errorf("\"OldMap\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	{
		if len(t.OldMap) > 4096 {
			return fmt.Errorf("cannot marshal t.OldMap map too large")
		}

		if err := jw.WriteObjectOpen(); err != nil {
			return fmt.Errorf("t.OldMap: %w", err)
		}

		keys := make([]string, 0, len(t.OldMap))
		for k := range t.OldMap {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for i, k := range keys {
			if i > 0 {
				if err := jw.WriteComma(); err != nil {
					return fmt.Errorf("t.OldMap: %w", err)
				}
			}
			v := t.OldMap[k]
			if len(k) > 8192 {
				return fmt.Errorf("String in field k was too long")
			}
			if err := jw.WriteString(string(k)); err != nil {
				return fmt.Errorf("k: %w", err)
			}
			if err := jw.WriteObjectColon(); err != nil {
				return fmt.Errorf("t.OldMap: %w", err)
			}

			if err := v.MarshalDagJSON(jw); err != nil {
				return fmt.Errorf("v: %w", err)
			}
		}
		if err := jw.WriteObjectClose(); err != nil {
			return fmt.Errorf("t.OldMap: %w", err)
		}
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldNum (uint64) (uint64)
	if len("OldNum") > 8192 {
		return fmt.Errorf("String in field \"OldNum\" was too long")
	}
	if err := jw.WriteString(string("OldNum")); err != nil {
		return fmt.Errorf("\"OldNum\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteUint64(uint64(t.OldNum)); err != nil {
		return fmt.Errorf("t.OldNum: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldPtr (cid.Cid) (struct)
	if len("OldPtr") > 8192 {
		return fmt.Errorf("String in field \"OldPtr\" was too long")
	}
	if err := jw.WriteString(string("OldPtr")); err != nil {
		return fmt.Errorf("\"OldPtr\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if t.OldPtr == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("t.OldPtr: %w", err)
		}
	} else {
		if err := jw.WriteCid(*t.OldPtr); err != nil {
			return fmt.Errorf("t.OldPtr: %w", err)
		}
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldStr (string) (string)
	if len("OldStr") > 8192 {
		return fmt.Errorf("String in field \"OldStr\" was too long")
	}
	if err := jw.WriteString(string("OldStr")); err != nil {
		return fmt.Errorf("\"OldStr\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.OldStr) > 8192 {
		return fmt.Errorf("String in field t.OldStr was too long")
	}
	if err := jw.WriteString(string(t.OldStr)); err != nil {
		return fmt.Errorf("t.OldStr: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldArray ([]testing.SimpleTypeOne) (slice)
	if len("OldArray") > 8192 {
		return fmt.Errorf("String in field \"OldArray\" was too long")
	}
	if err := jw.WriteString(string("OldArray")); err != nil {
		return fmt.Errorf("\"OldArray\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.OldArray) > 8192 {
		return fmt.Errorf("Slice value in field t.OldArray was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.OldArray: %w", err)
	}
	for i, v := range t.OldArray {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.OldArray: %w", err)
			}
		}
		if err := v.MarshalDagJSON(jw); err != nil {
			return fmt.Errorf("v: %w", err)
		}
	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.OldArray: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldBytes ([]uint8) (slice)
	if len("OldBytes") > 8192 {
		return fmt.Errorf("String in field \"OldBytes\" was too long")
	}
	if err := jw.WriteString(string("OldBytes")); err != nil {
		return fmt.Errorf("\"OldBytes\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.OldBytes) > 2097152 {
		return fmt.Errorf("Byte array in field t.OldBytes was too long")
	}

	if err := jw.WriteBytes(t.OldBytes); err != nil {
		return fmt.Errorf("t.OldBytes: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldStruct (testing.SimpleTypeOne) (struct)
	if len("OldStruct") > 8192 {
		return fmt.Errorf("String in field \"OldStruct\" was too long")
	}
	if err := jw.WriteString(string("OldStruct")); err != nil {
		return fmt.Errorf("\"OldStruct\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if err := t.OldStruct.MarshalDagJSON(jw); err != nil {
		return fmt.Errorf("t.OldStruct: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldCidArray ([]cid.Cid) (slice)
	if len("OldCidArray") > 8192 {
		return fmt.Errorf("String in field \"OldCidArray\" was too long")
	}
	if err := jw.WriteString(string("OldCidArray")); err != nil {
		return fmt.Errorf("\"OldCidArray\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.OldCidArray) > 8192 {
		return fmt.Errorf("Slice value in field t.OldCidArray was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.OldCidArray: %w", err)
	}
	for i, v := range t.OldCidArray {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.OldCidArray: %w", err)
			}
		}

		if err := jw.WriteCid(v); err != nil {
			return fmt.Errorf("v: %w", err)
		}

	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.OldCidArray: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldCidPtrArray ([]*cid.Cid) (slice)
	if len("OldCidPtrArray") > 8192 {
		return fmt.Errorf("String in field \"OldCidPtrArray\" was too long")
	}
	if err := jw.WriteString(string("OldCidPtrArray")); err != nil {
		return fmt.Errorf("\"OldCidPtrArray\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.OldCidPtrArray) > 8192 {
		return fmt.Errorf("Slice value in field t.OldCidPtrArray was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.OldCidPtrArray: %w", err)
	}
	for i, v := range t.OldCidPtrArray {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.OldCidPtrArray: %w", err)
			}
		}

		if v == nil {
			if err := jw.WriteNull(); err != nil {
				return fmt.Errorf("v: %w", err)
			}
		} else {
			if err := jw.WriteCid(*v); err != nil {
				return fmt.Errorf("v: %w", err)
			}
		}

	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.OldCidPtrArray: %w", err)
	}

	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *SimpleStructV1) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = SimpleStructV1{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("SimpleStructV1: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("SimpleStructV1: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("SimpleStructV1: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("SimpleStructV1: string too large")
				}
				return fmt.Errorf("SimpleStructV1: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("SimpleStructV1: %w", err)
			}
			switch name {

			// t.OldMap (map[string]testing.SimpleTypeOne) (map)
			case "OldMap":
				if err := jr.ReadObjectOpen(); err != nil {
					return fmt.Errorf("t.OldMap: %w", err)
				}

				t.OldMap = map[string]SimpleTypeOne{}

				close, err := jr.PeekObjectClose()
				if err != nil {
					return fmt.Errorf("t.OldMap: %w", err)
				}
				if close {
					if err := jr.ReadObjectClose(); err != nil {
						return fmt.Errorf("t.OldMap: %w", err)
					}
				} else {
					for i, l := 0, 8192; i < l; i++ {
						var k string
						{
							sval, err := jr.ReadString(8192)
							if err != nil {
								if errors.Is(err, jsg.ErrLimitExceeded) {
									return fmt.Errorf("k: string too long")
								}
								return fmt.Errorf("k: %w", err)
							}
							k = string(sval)
						}
						if err := jr.ReadObjectColon(); err != nil {
							return fmt.Errorf("t.OldMap: %w", err)
						}
						var v SimpleTypeOne

						if err := v.UnmarshalDagJSON(jr); err != nil {
							return fmt.Errorf("unmarshaling v: %w", err)
						}

						t.OldMap[k] = v
						close, err := jr.ReadObjectCloseOrComma()
						if err != nil {
							return fmt.Errorf("t.OldMap: %w", err)
						}
						if close {
							break
						}
					}
				}

				// t.OldNum (uint64) (uint64)
			case "OldNum":
				{

					nval, err := jr.ReadNumberAsUint64()
					if err != nil {
						return fmt.Errorf("t.OldNum: %w", err)
					}
					t.OldNum = uint64(nval)

				}

				// t.OldPtr (cid.Cid) (struct)
			case "OldPtr":
				{

					c, err := jr.ReadCidOrNull()
					if err != nil {
						return fmt.Errorf("t.OldPtr: %w", err)
					}
					t.OldPtr = c

				}

				// t.OldStr (string) (string)
			case "OldStr":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.OldStr: string too long")
						}
						return fmt.Errorf("t.OldStr: %w", err)
					}
					t.OldStr = string(sval)
				}

				// t.OldArray ([]testing.SimpleTypeOne) (slice)
			case "OldArray":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.OldArray: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.OldArray: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.OldArray: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]SimpleTypeOne, 1)

							if err := item[0].UnmarshalDagJSON(jr); err != nil {
								return fmt.Errorf("unmarshaling item[0]: %w", err)
							}

							t.OldArray = append(t.OldArray, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.OldArray: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.OldArray: slice too large")
							}
						}
					}

				}

				// t.OldBytes ([]uint8) (slice)
			case "OldBytes":

				{
					bval, err := jr.ReadBytes(2097152)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.OldBytes: byte array too large")
						}
						return fmt.Errorf("t.OldBytes: %w", err)
					}
					if len(bval) > 0 {
						t.OldBytes = []uint8(bval)
					}
				}

				// t.OldStruct (testing.SimpleTypeOne) (struct)
			case "OldStruct":

				if err := t.OldStruct.UnmarshalDagJSON(jr); err != nil {
					return fmt.Errorf("unmarshaling t.OldStruct: %w", err)
				}

				// t.OldCidArray ([]cid.Cid) (slice)
			case "OldCidArray":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.OldCidArray: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.OldCidArray: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.OldCidArray: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]cid.Cid, 1)
							{

								c, err := jr.ReadCid()
								if err != nil {
									return fmt.Errorf("item[0]: %w", err)
								}
								item[0] = c

							}
							t.OldCidArray = append(t.OldCidArray, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.OldCidArray: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.OldCidArray: slice too large")
							}
						}
					}

				}

				// t.OldCidPtrArray ([]*cid.Cid) (slice)
			case "OldCidPtrArray":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.OldCidPtrArray: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.OldCidPtrArray: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.OldCidPtrArray: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]*cid.Cid, 1)
							{

								c, err := jr.ReadCidOrNull()
								if err != nil {
									return fmt.Errorf("item[0]: %w", err)
								}
								item[0] = c

							}
							t.OldCidPtrArray = append(t.OldCidPtrArray, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.OldCidPtrArray: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.OldCidPtrArray: slice too large")
							}
						}
					}

				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("SimpleStructV1: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("SimpleStructV1: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("SimpleStructV1: map too large")
			}
		}
	}

	return nil
}
func (t *SimpleStructV2) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.NewMap (map[string]testing.SimpleTypeOne) (map)
	if len("NewMap") > 8192 {
		return fmt.Errorf("String in field \"NewMap\" was too long")
	}
	if err := jw.WriteString(string("NewMap")); err != nil {
		return fmt.Errorf("\"NewMap\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	{
		if len(t.NewMap) > 4096 {
			return fmt.Errorf("cannot marshal t.NewMap map too large")
		}

		if err := jw.WriteObjectOpen(); err != nil {
			return fmt.Errorf("t.NewMap: %w", err)
		}

		keys := make([]string, 0, len(t.NewMap))
		for k := range t.NewMap {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for i, k := range keys {
			if i > 0 {
				if err := jw.WriteComma(); err != nil {
					return fmt.Errorf("t.NewMap: %w", err)
				}
			}
			v := t.NewMap[k]
			if len(k) > 8192 {
				return fmt.Errorf("String in field k was too long")
			}
			if err := jw.WriteString(string(k)); err != nil {
				return fmt.Errorf("k: %w", err)
			}
			if err := jw.WriteObjectColon(); err != nil {
				return fmt.Errorf("t.NewMap: %w", err)
			}

			if err := v.MarshalDagJSON(jw); err != nil {
				return fmt.Errorf("v: %w", err)
			}
		}
		if err := jw.WriteObjectClose(); err != nil {
			return fmt.Errorf("t.NewMap: %w", err)
		}
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.NewNum (uint64) (uint64)
	if len("NewNum") > 8192 {
		return fmt.Errorf("String in field \"NewNum\" was too long")
	}
	if err := jw.WriteString(string("NewNum")); err != nil {
		return fmt.Errorf("\"NewNum\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteUint64(uint64(t.NewNum)); err != nil {
		return fmt.Errorf("t.NewNum: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.NewPtr (cid.Cid) (struct)
	if len("NewPtr") > 8192 {
		return fmt.Errorf("String in field \"NewPtr\" was too long")
	}
	if err := jw.WriteString(string("NewPtr")); err != nil {
		return fmt.Errorf("\"NewPtr\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if t.NewPtr == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("t.NewPtr: %w", err)
		}
	} else {
		if err := jw.WriteCid(*t.NewPtr); err != nil {
			return fmt.Errorf("t.NewPtr: %w", err)
		}
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.NewStr (string) (string)
	if len("NewStr") > 8192 {
		return fmt.Errorf("String in field \"NewStr\" was too long")
	}
	if err := jw.WriteString(string("NewStr")); err != nil {
		return fmt.Errorf("\"NewStr\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.NewStr) > 8192 {
		return fmt.Errorf("String in field t.NewStr was too long")
	}
	if err := jw.WriteString(string(t.NewStr)); err != nil {
		return fmt.Errorf("t.NewStr: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldMap (map[string]testing.SimpleTypeOne) (map)
	if len("OldMap") > 8192 {
		return fmt.Errorf("String in field \"OldMap\" was too long")
	}
	if err := jw.WriteString(string("OldMap")); err != nil {
		return fmt.Errorf("\"OldMap\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	{
		if len(t.OldMap) > 4096 {
			return fmt.Errorf("cannot marshal t.OldMap map too large")
		}

		if err := jw.WriteObjectOpen(); err != nil {
			return fmt.Errorf("t.OldMap: %w", err)
		}

		keys := make([]string, 0, len(t.OldMap))
		for k := range t.OldMap {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for i, k := range keys {
			if i > 0 {
				if err := jw.WriteComma(); err != nil {
					return fmt.Errorf("t.OldMap: %w", err)
				}
			}
			v := t.OldMap[k]
			if len(k) > 8192 {
				return fmt.Errorf("String in field k was too long")
			}
			if err := jw.WriteString(string(k)); err != nil {
				return fmt.Errorf("k: %w", err)
			}
			if err := jw.WriteObjectColon(); err != nil {
				return fmt.Errorf("t.OldMap: %w", err)
			}

			if err := v.MarshalDagJSON(jw); err != nil {
				return fmt.Errorf("v: %w", err)
			}
		}
		if err := jw.WriteObjectClose(); err != nil {
			return fmt.Errorf("t.OldMap: %w", err)
		}
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldNum (uint64) (uint64)
	if len("OldNum") > 8192 {
		return fmt.Errorf("String in field \"OldNum\" was too long")
	}
	if err := jw.WriteString(string("OldNum")); err != nil {
		return fmt.Errorf("\"OldNum\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteUint64(uint64(t.OldNum)); err != nil {
		return fmt.Errorf("t.OldNum: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldPtr (cid.Cid) (struct)
	if len("OldPtr") > 8192 {
		return fmt.Errorf("String in field \"OldPtr\" was too long")
	}
	if err := jw.WriteString(string("OldPtr")); err != nil {
		return fmt.Errorf("\"OldPtr\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if t.OldPtr == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("t.OldPtr: %w", err)
		}
	} else {
		if err := jw.WriteCid(*t.OldPtr); err != nil {
			return fmt.Errorf("t.OldPtr: %w", err)
		}
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldStr (string) (string)
	if len("OldStr") > 8192 {
		return fmt.Errorf("String in field \"OldStr\" was too long")
	}
	if err := jw.WriteString(string("OldStr")); err != nil {
		return fmt.Errorf("\"OldStr\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.OldStr) > 8192 {
		return fmt.Errorf("String in field t.OldStr was too long")
	}
	if err := jw.WriteString(string(t.OldStr)); err != nil {
		return fmt.Errorf("t.OldStr: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.NewArray ([]testing.SimpleTypeOne) (slice)
	if len("NewArray") > 8192 {
		return fmt.Errorf("String in field \"NewArray\" was too long")
	}
	if err := jw.WriteString(string("NewArray")); err != nil {
		return fmt.Errorf("\"NewArray\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.NewArray) > 8192 {
		return fmt.Errorf("Slice value in field t.NewArray was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.NewArray: %w", err)
	}
	for i, v := range t.NewArray {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.NewArray: %w", err)
			}
		}
		if err := v.MarshalDagJSON(jw); err != nil {
			return fmt.Errorf("v: %w", err)
		}
	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.NewArray: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.NewBytes ([]uint8) (slice)
	if len("NewBytes") > 8192 {
		return fmt.Errorf("String in field \"NewBytes\" was too long")
	}
	if err := jw.WriteString(string("NewBytes")); err != nil {
		return fmt.Errorf("\"NewBytes\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.NewBytes) > 2097152 {
		return fmt.Errorf("Byte array in field t.NewBytes was too long")
	}

	if err := jw.WriteBytes(t.NewBytes); err != nil {
		return fmt.Errorf("t.NewBytes: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldArray ([]testing.SimpleTypeOne) (slice)
	if len("OldArray") > 8192 {
		return fmt.Errorf("String in field \"OldArray\" was too long")
	}
	if err := jw.WriteString(string("OldArray")); err != nil {
		return fmt.Errorf("\"OldArray\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.OldArray) > 8192 {
		return fmt.Errorf("Slice value in field t.OldArray was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.OldArray: %w", err)
	}
	for i, v := range t.OldArray {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.OldArray: %w", err)
			}
		}
		if err := v.MarshalDagJSON(jw); err != nil {
			return fmt.Errorf("v: %w", err)
		}
	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.OldArray: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldBytes ([]uint8) (slice)
	if len("OldBytes") > 8192 {
		return fmt.Errorf("String in field \"OldBytes\" was too long")
	}
	if err := jw.WriteString(string("OldBytes")); err != nil {
		return fmt.Errorf("\"OldBytes\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.OldBytes) > 2097152 {
		return fmt.Errorf("Byte array in field t.OldBytes was too long")
	}

	if err := jw.WriteBytes(t.OldBytes); err != nil {
		return fmt.Errorf("t.OldBytes: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.NewStruct (testing.SimpleTypeOne) (struct)
	if len("NewStruct") > 8192 {
		return fmt.Errorf("String in field \"NewStruct\" was too long")
	}
	if err := jw.WriteString(string("NewStruct")); err != nil {
		return fmt.Errorf("\"NewStruct\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if err := t.NewStruct.MarshalDagJSON(jw); err != nil {
		return fmt.Errorf("t.NewStruct: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.OldStruct (testing.SimpleTypeOne) (struct)
	if len("OldStruct") > 8192 {
		return fmt.Errorf("String in field \"OldStruct\" was too long")
	}
	if err := jw.WriteString(string("OldStruct")); err != nil {
		return fmt.Errorf("\"OldStruct\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if err := t.OldStruct.MarshalDagJSON(jw); err != nil {
		return fmt.Errorf("t.OldStruct: %w", err)
	}
	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *SimpleStructV2) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = SimpleStructV2{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("SimpleStructV2: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("SimpleStructV2: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("SimpleStructV2: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("SimpleStructV2: string too large")
				}
				return fmt.Errorf("SimpleStructV2: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("SimpleStructV2: %w", err)
			}
			switch name {

			// t.NewMap (map[string]testing.SimpleTypeOne) (map)
			case "NewMap":
				if err := jr.ReadObjectOpen(); err != nil {
					return fmt.Errorf("t.NewMap: %w", err)
				}

				t.NewMap = map[string]SimpleTypeOne{}

				close, err := jr.PeekObjectClose()
				if err != nil {
					return fmt.Errorf("t.NewMap: %w", err)
				}
				if close {
					if err := jr.ReadObjectClose(); err != nil {
						return fmt.Errorf("t.NewMap: %w", err)
					}
				} else {
					for i, l := 0, 8192; i < l; i++ {
						var k string
						{
							sval, err := jr.ReadString(8192)
							if err != nil {
								if errors.Is(err, jsg.ErrLimitExceeded) {
									return fmt.Errorf("k: string too long")
								}
								return fmt.Errorf("k: %w", err)
							}
							k = string(sval)
						}
						if err := jr.ReadObjectColon(); err != nil {
							return fmt.Errorf("t.NewMap: %w", err)
						}
						var v SimpleTypeOne

						if err := v.UnmarshalDagJSON(jr); err != nil {
							return fmt.Errorf("unmarshaling v: %w", err)
						}

						t.NewMap[k] = v
						close, err := jr.ReadObjectCloseOrComma()
						if err != nil {
							return fmt.Errorf("t.NewMap: %w", err)
						}
						if close {
							break
						}
					}
				}

				// t.NewNum (uint64) (uint64)
			case "NewNum":
				{

					nval, err := jr.ReadNumberAsUint64()
					if err != nil {
						return fmt.Errorf("t.NewNum: %w", err)
					}
					t.NewNum = uint64(nval)

				}

				// t.NewPtr (cid.Cid) (struct)
			case "NewPtr":
				{

					c, err := jr.ReadCidOrNull()
					if err != nil {
						return fmt.Errorf("t.NewPtr: %w", err)
					}
					t.NewPtr = c

				}

				// t.NewStr (string) (string)
			case "NewStr":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.NewStr: string too long")
						}
						return fmt.Errorf("t.NewStr: %w", err)
					}
					t.NewStr = string(sval)
				}

				// t.OldMap (map[string]testing.SimpleTypeOne) (map)
			case "OldMap":
				if err := jr.ReadObjectOpen(); err != nil {
					return fmt.Errorf("t.OldMap: %w", err)
				}

				t.OldMap = map[string]SimpleTypeOne{}

				close, err := jr.PeekObjectClose()
				if err != nil {
					return fmt.Errorf("t.OldMap: %w", err)
				}
				if close {
					if err := jr.ReadObjectClose(); err != nil {
						return fmt.Errorf("t.OldMap: %w", err)
					}
				} else {
					for i, l := 0, 8192; i < l; i++ {
						var k string
						{
							sval, err := jr.ReadString(8192)
							if err != nil {
								if errors.Is(err, jsg.ErrLimitExceeded) {
									return fmt.Errorf("k: string too long")
								}
								return fmt.Errorf("k: %w", err)
							}
							k = string(sval)
						}
						if err := jr.ReadObjectColon(); err != nil {
							return fmt.Errorf("t.OldMap: %w", err)
						}
						var v SimpleTypeOne

						if err := v.UnmarshalDagJSON(jr); err != nil {
							return fmt.Errorf("unmarshaling v: %w", err)
						}

						t.OldMap[k] = v
						close, err := jr.ReadObjectCloseOrComma()
						if err != nil {
							return fmt.Errorf("t.OldMap: %w", err)
						}
						if close {
							break
						}
					}
				}

				// t.OldNum (uint64) (uint64)
			case "OldNum":
				{

					nval, err := jr.ReadNumberAsUint64()
					if err != nil {
						return fmt.Errorf("t.OldNum: %w", err)
					}
					t.OldNum = uint64(nval)

				}

				// t.OldPtr (cid.Cid) (struct)
			case "OldPtr":
				{

					c, err := jr.ReadCidOrNull()
					if err != nil {
						return fmt.Errorf("t.OldPtr: %w", err)
					}
					t.OldPtr = c

				}

				// t.OldStr (string) (string)
			case "OldStr":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.OldStr: string too long")
						}
						return fmt.Errorf("t.OldStr: %w", err)
					}
					t.OldStr = string(sval)
				}

				// t.NewArray ([]testing.SimpleTypeOne) (slice)
			case "NewArray":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.NewArray: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.NewArray: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.NewArray: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]SimpleTypeOne, 1)

							if err := item[0].UnmarshalDagJSON(jr); err != nil {
								return fmt.Errorf("unmarshaling item[0]: %w", err)
							}

							t.NewArray = append(t.NewArray, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.NewArray: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.NewArray: slice too large")
							}
						}
					}

				}

				// t.NewBytes ([]uint8) (slice)
			case "NewBytes":

				{
					bval, err := jr.ReadBytes(2097152)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.NewBytes: byte array too large")
						}
						return fmt.Errorf("t.NewBytes: %w", err)
					}
					if len(bval) > 0 {
						t.NewBytes = []uint8(bval)
					}
				}

				// t.OldArray ([]testing.SimpleTypeOne) (slice)
			case "OldArray":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.OldArray: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.OldArray: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.OldArray: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]SimpleTypeOne, 1)

							if err := item[0].UnmarshalDagJSON(jr); err != nil {
								return fmt.Errorf("unmarshaling item[0]: %w", err)
							}

							t.OldArray = append(t.OldArray, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.OldArray: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.OldArray: slice too large")
							}
						}
					}

				}

				// t.OldBytes ([]uint8) (slice)
			case "OldBytes":

				{
					bval, err := jr.ReadBytes(2097152)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.OldBytes: byte array too large")
						}
						return fmt.Errorf("t.OldBytes: %w", err)
					}
					if len(bval) > 0 {
						t.OldBytes = []uint8(bval)
					}
				}

				// t.NewStruct (testing.SimpleTypeOne) (struct)
			case "NewStruct":

				if err := t.NewStruct.UnmarshalDagJSON(jr); err != nil {
					return fmt.Errorf("unmarshaling t.NewStruct: %w", err)
				}

				// t.OldStruct (testing.SimpleTypeOne) (struct)
			case "OldStruct":

				if err := t.OldStruct.UnmarshalDagJSON(jr); err != nil {
					return fmt.Errorf("unmarshaling t.OldStruct: %w", err)
				}

			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("SimpleStructV2: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("SimpleStructV2: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("SimpleStructV2: map too large")
			}
		}
	}

	return nil
}
func (t *RenamedFields) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.Foo (int64) (int64)
	if len("foo") > 8192 {
		return fmt.Errorf("String in field \"foo\" was too long")
	}
	if err := jw.WriteString(string("foo")); err != nil {
		return fmt.Errorf("\"foo\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteInt64(int64(t.Foo)); err != nil {
		return fmt.Errorf("t.Foo: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Bar (string) (string)
	if len("beep") > 8192 {
		return fmt.Errorf("String in field \"beep\" was too long")
	}
	if err := jw.WriteString(string("beep")); err != nil {
		return fmt.Errorf("\"beep\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Bar) > 8192 {
		return fmt.Errorf("String in field t.Bar was too long")
	}
	if err := jw.WriteString(string(t.Bar)); err != nil {
		return fmt.Errorf("t.Bar: %w", err)
	}
	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *RenamedFields) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = RenamedFields{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("RenamedFields: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("RenamedFields: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("RenamedFields: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("RenamedFields: string too large")
				}
				return fmt.Errorf("RenamedFields: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("RenamedFields: %w", err)
			}
			switch name {

			// t.Foo (int64) (int64)
			case "foo":
				{

					nval, err := jr.ReadNumberAsInt64()
					if err != nil {
						return fmt.Errorf("t.Foo: %w", err)
					}
					t.Foo = int64(nval)

				}

				// t.Bar (string) (string)
			case "beep":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Bar: string too long")
						}
						return fmt.Errorf("t.Bar: %w", err)
					}
					t.Bar = string(sval)
				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("RenamedFields: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("RenamedFields: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("RenamedFields: map too large")
			}
		}
	}

	return nil
}
func (t *TestEmpty) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.Cat (int64) (int64)
	if len("Cat") > 8192 {
		return fmt.Errorf("String in field \"Cat\" was too long")
	}
	if err := jw.WriteString(string("Cat")); err != nil {
		return fmt.Errorf("\"Cat\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteInt64(int64(t.Cat)); err != nil {
		return fmt.Errorf("t.Cat: %w", err)
	}

	written++
	if t.Foo != nil {
		if written > 0 {
			if err := jw.WriteComma(); err != nil {
				return err
			}
		}
	}

	// t.Foo (string) (string)
	if t.Foo != nil {
		if len("Foo") > 8192 {
			return fmt.Errorf("String in field \"Foo\" was too long")
		}
		if err := jw.WriteString(string("Foo")); err != nil {
			return fmt.Errorf("\"Foo\": %w", err)
		}
		if err := jw.WriteObjectColon(); err != nil {
			return err
		}
		if t.Foo == nil {
			if err := jw.WriteNull(); err != nil {
				return fmt.Errorf("t.Foo: %w", err)
			}
		} else {
			if len(*t.Foo) > 8192 {
				return fmt.Errorf("String in field t.Foo was too long")
			}
			if err := jw.WriteString(string(*t.Foo)); err != nil {
				return fmt.Errorf("t.Foo: %w", err)
			}
		}
		written++
	}
	if t.Beep != "" {
		if written > 0 {
			if err := jw.WriteComma(); err != nil {
				return err
			}
		}
	}

	// t.Beep (string) (string)
	if t.Beep != "" {
		if len("Beep") > 8192 {
			return fmt.Errorf("String in field \"Beep\" was too long")
		}
		if err := jw.WriteString(string("Beep")); err != nil {
			return fmt.Errorf("\"Beep\": %w", err)
		}
		if err := jw.WriteObjectColon(); err != nil {
			return err
		}
		if len(t.Beep) > 8192 {
			return fmt.Errorf("String in field t.Beep was too long")
		}
		if err := jw.WriteString(string(t.Beep)); err != nil {
			return fmt.Errorf("t.Beep: %w", err)
		}
		written++
	}
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *TestEmpty) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = TestEmpty{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("TestEmpty: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("TestEmpty: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("TestEmpty: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("TestEmpty: string too large")
				}
				return fmt.Errorf("TestEmpty: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("TestEmpty: %w", err)
			}
			switch name {

			// t.Cat (int64) (int64)
			case "Cat":
				{

					nval, err := jr.ReadNumberAsInt64()
					if err != nil {
						return fmt.Errorf("t.Cat: %w", err)
					}
					t.Cat = int64(nval)

				}

				// t.Foo (string) (string)
			case "Foo":
				{
					sval, err := jr.ReadStringOrNull(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Foo: string too long")
						}
						return fmt.Errorf("t.Foo: %w", err)
					}
					if sval != nil {
						t.Foo = (*string)(sval)
					}
				}

				// t.Beep (string) (string)
			case "Beep":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Beep: string too long")
						}
						return fmt.Errorf("t.Beep: %w", err)
					}
					t.Beep = string(sval)
				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("TestEmpty: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("TestEmpty: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("TestEmpty: map too large")
			}
		}
	}

	return nil
}
func (t *TestConstField) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.Cats (string) (string)
	if len("Cats") > 8192 {
		return fmt.Errorf("String in field \"Cats\" was too long")
	}
	if err := jw.WriteString(string("Cats")); err != nil {
		return fmt.Errorf("\"Cats\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if err := jw.WriteString("dogsdrool"); err != nil {
		return err
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Thing (int64) (int64)
	if len("Thing") > 8192 {
		return fmt.Errorf("String in field \"Thing\" was too long")
	}
	if err := jw.WriteString(string("Thing")); err != nil {
		return fmt.Errorf("\"Thing\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteInt64(int64(t.Thing)); err != nil {
		return fmt.Errorf("t.Thing: %w", err)
	}

	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *TestConstField) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = TestConstField{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("TestConstField: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("TestConstField: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("TestConstField: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("TestConstField: string too large")
				}
				return fmt.Errorf("TestConstField: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("TestConstField: %w", err)
			}
			switch name {

			// t.Cats (string) (string)
			case "Cats":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Cats: string too long")
						}
						return fmt.Errorf("t.Cats: %w", err)
					}
					t.Cats = string(sval)
				}

				// t.Thing (int64) (int64)
			case "Thing":
				{

					nval, err := jr.ReadNumberAsInt64()
					if err != nil {
						return fmt.Errorf("t.Thing: %w", err)
					}
					t.Thing = int64(nval)

				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("TestConstField: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("TestConstField: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("TestConstField: map too large")
			}
		}
	}

	return nil
}
func (t *TestCanonicalFieldOrder) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.Zp (string) (string)
	if len("ap") > 8192 {
		return fmt.Errorf("String in field \"ap\" was too long")
	}
	if err := jw.WriteString(string("ap")); err != nil {
		return fmt.Errorf("\"ap\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Zp) > 8192 {
		return fmt.Errorf("String in field t.Zp was too long")
	}
	if err := jw.WriteString(string(t.Zp)); err != nil {
		return fmt.Errorf("t.Zp: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Foo (int64) (int64)
	if len("foo") > 8192 {
		return fmt.Errorf("String in field \"foo\" was too long")
	}
	if err := jw.WriteString(string("foo")); err != nil {
		return fmt.Errorf("\"foo\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteInt64(int64(t.Foo)); err != nil {
		return fmt.Errorf("t.Foo: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Bar (string) (string)
	if len("beep") > 8192 {
		return fmt.Errorf("String in field \"beep\" was too long")
	}
	if err := jw.WriteString(string("beep")); err != nil {
		return fmt.Errorf("\"beep\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Bar) > 8192 {
		return fmt.Errorf("String in field t.Bar was too long")
	}
	if err := jw.WriteString(string(t.Bar)); err != nil {
		return fmt.Errorf("t.Bar: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Drond (int64) (int64)
	if len("Drond") > 8192 {
		return fmt.Errorf("String in field \"Drond\" was too long")
	}
	if err := jw.WriteString(string("Drond")); err != nil {
		return fmt.Errorf("\"Drond\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteInt64(int64(t.Drond)); err != nil {
		return fmt.Errorf("t.Drond: %w", err)
	}

	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *TestCanonicalFieldOrder) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = TestCanonicalFieldOrder{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("TestCanonicalFieldOrder: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("TestCanonicalFieldOrder: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("TestCanonicalFieldOrder: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("TestCanonicalFieldOrder: string too large")
				}
				return fmt.Errorf("TestCanonicalFieldOrder: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("TestCanonicalFieldOrder: %w", err)
			}
			switch name {

			// t.Zp (string) (string)
			case "ap":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Zp: string too long")
						}
						return fmt.Errorf("t.Zp: %w", err)
					}
					t.Zp = string(sval)
				}

				// t.Foo (int64) (int64)
			case "foo":
				{

					nval, err := jr.ReadNumberAsInt64()
					if err != nil {
						return fmt.Errorf("t.Foo: %w", err)
					}
					t.Foo = int64(nval)

				}

				// t.Bar (string) (string)
			case "beep":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Bar: string too long")
						}
						return fmt.Errorf("t.Bar: %w", err)
					}
					t.Bar = string(sval)
				}

				// t.Drond (int64) (int64)
			case "Drond":
				{

					nval, err := jr.ReadNumberAsInt64()
					if err != nil {
						return fmt.Errorf("t.Drond: %w", err)
					}
					t.Drond = int64(nval)

				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("TestCanonicalFieldOrder: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("TestCanonicalFieldOrder: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("TestCanonicalFieldOrder: map too large")
			}
		}
	}

	return nil
}
func (t *MapStringString) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}

	// t.Snorkleblump (map[string]string) (map)
	if len("Snorkleblump") > 8192 {
		return fmt.Errorf("String in field \"Snorkleblump\" was too long")
	}
	if err := jw.WriteString(string("Snorkleblump")); err != nil {
		return fmt.Errorf("\"Snorkleblump\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	{
		if len(t.Snorkleblump) > 4096 {
			return fmt.Errorf("cannot marshal t.Snorkleblump map too large")
		}

		if err := jw.WriteObjectOpen(); err != nil {
			return fmt.Errorf("t.Snorkleblump: %w", err)
		}

		keys := make([]string, 0, len(t.Snorkleblump))
		for k := range t.Snorkleblump {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for i, k := range keys {
			if i > 0 {
				if err := jw.WriteComma(); err != nil {
					return fmt.Errorf("t.Snorkleblump: %w", err)
				}
			}
			v := t.Snorkleblump[k]
			if len(k) > 8192 {
				return fmt.Errorf("String in field k was too long")
			}
			if err := jw.WriteString(string(k)); err != nil {
				return fmt.Errorf("k: %w", err)
			}
			if err := jw.WriteObjectColon(); err != nil {
				return fmt.Errorf("t.Snorkleblump: %w", err)
			}

			if len(v) > 8192 {
				return fmt.Errorf("String in field v was too long")
			}
			if err := jw.WriteString(string(v)); err != nil {
				return fmt.Errorf("v: %w", err)
			}
		}
		if err := jw.WriteObjectClose(); err != nil {
			return fmt.Errorf("t.Snorkleblump: %w", err)
		}
	}

	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *MapStringString) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = MapStringString{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("MapStringString: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("MapStringString: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("MapStringString: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("MapStringString: string too large")
				}
				return fmt.Errorf("MapStringString: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("MapStringString: %w", err)
			}
			switch name {

			// t.Snorkleblump (map[string]string) (map)
			case "Snorkleblump":
				if err := jr.ReadObjectOpen(); err != nil {
					return fmt.Errorf("t.Snorkleblump: %w", err)
				}

				t.Snorkleblump = map[string]string{}

				close, err := jr.PeekObjectClose()
				if err != nil {
					return fmt.Errorf("t.Snorkleblump: %w", err)
				}
				if close {
					if err := jr.ReadObjectClose(); err != nil {
						return fmt.Errorf("t.Snorkleblump: %w", err)
					}
				} else {
					for i, l := 0, 8192; i < l; i++ {
						var k string
						{
							sval, err := jr.ReadString(8192)
							if err != nil {
								if errors.Is(err, jsg.ErrLimitExceeded) {
									return fmt.Errorf("k: string too long")
								}
								return fmt.Errorf("k: %w", err)
							}
							k = string(sval)
						}
						if err := jr.ReadObjectColon(); err != nil {
							return fmt.Errorf("t.Snorkleblump: %w", err)
						}
						var v string
						{
							sval, err := jr.ReadString(8192)
							if err != nil {
								if errors.Is(err, jsg.ErrLimitExceeded) {
									return fmt.Errorf("v: string too long")
								}
								return fmt.Errorf("v: %w", err)
							}
							v = string(sval)
						}
						t.Snorkleblump[k] = v
						close, err := jr.ReadObjectCloseOrComma()
						if err != nil {
							return fmt.Errorf("t.Snorkleblump: %w", err)
						}
						if close {
							break
						}
					}
				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("MapStringString: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("MapStringString: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("MapStringString: map too large")
			}
		}
	}

	return nil
}
func (t *TestSliceNilPreserve) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.Cat (string) (string)
	if len("Cat") > 8192 {
		return fmt.Errorf("String in field \"Cat\" was too long")
	}
	if err := jw.WriteString(string("Cat")); err != nil {
		return fmt.Errorf("\"Cat\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Cat) > 8192 {
		return fmt.Errorf("String in field t.Cat was too long")
	}
	if err := jw.WriteString(string(t.Cat)); err != nil {
		return fmt.Errorf("t.Cat: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Not ([]uint64) (slice)
	if len("Not") > 8192 {
		return fmt.Errorf("String in field \"Not\" was too long")
	}
	if err := jw.WriteString(string("Not")); err != nil {
		return fmt.Errorf("\"Not\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Not) > 8192 {
		return fmt.Errorf("Slice value in field t.Not was too long")
	}

	if t.Not == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("t.Not: %w", err)
		}
	} else {

		if err := jw.WriteArrayOpen(); err != nil {
			return fmt.Errorf("t.Not: %w", err)
		}
		for i, v := range t.Not {
			if i > 0 {
				if err := jw.WriteComma(); err != nil {
					return fmt.Errorf("t.Not: %w", err)
				}
			}

			if err := jw.WriteUint64(uint64(v)); err != nil {
				return fmt.Errorf("v: %w", err)
			}

		}
		if err := jw.WriteArrayClose(); err != nil {
			return fmt.Errorf("t.Not: %w", err)
		}

	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Beep (int64) (int64)
	if len("Beep") > 8192 {
		return fmt.Errorf("String in field \"Beep\" was too long")
	}
	if err := jw.WriteString(string("Beep")); err != nil {
		return fmt.Errorf("\"Beep\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteInt64(int64(t.Beep)); err != nil {
		return fmt.Errorf("t.Beep: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Other ([]uint8) (slice)
	if len("Other") > 8192 {
		return fmt.Errorf("String in field \"Other\" was too long")
	}
	if err := jw.WriteString(string("Other")); err != nil {
		return fmt.Errorf("\"Other\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Other) > 2097152 {
		return fmt.Errorf("Byte array in field t.Other was too long")
	}

	if err := jw.WriteBytes(t.Other); err != nil {
		return fmt.Errorf("t.Other: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Stuff ([]uint64) (slice)
	if len("Stuff") > 8192 {
		return fmt.Errorf("String in field \"Stuff\" was too long")
	}
	if err := jw.WriteString(string("Stuff")); err != nil {
		return fmt.Errorf("\"Stuff\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Stuff) > 8192 {
		return fmt.Errorf("Slice value in field t.Stuff was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.Stuff: %w", err)
	}
	for i, v := range t.Stuff {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.Stuff: %w", err)
			}
		}

		if err := jw.WriteUint64(uint64(v)); err != nil {
			return fmt.Errorf("v: %w", err)
		}

	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.Stuff: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.NotOther ([]uint8) (slice)
	if len("NotOther") > 8192 {
		return fmt.Errorf("String in field \"NotOther\" was too long")
	}
	if err := jw.WriteString(string("NotOther")); err != nil {
		return fmt.Errorf("\"NotOther\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.NotOther) > 2097152 {
		return fmt.Errorf("Byte array in field t.NotOther was too long")
	}

	if t.NotOther == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("t.NotOther: %w", err)
		}
	} else {

		if err := jw.WriteBytes(t.NotOther); err != nil {
			return fmt.Errorf("t.NotOther: %w", err)
		}

	}

	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *TestSliceNilPreserve) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = TestSliceNilPreserve{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("TestSliceNilPreserve: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("TestSliceNilPreserve: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("TestSliceNilPreserve: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("TestSliceNilPreserve: string too large")
				}
				return fmt.Errorf("TestSliceNilPreserve: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("TestSliceNilPreserve: %w", err)
			}
			switch name {

			// t.Cat (string) (string)
			case "Cat":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Cat: string too long")
						}
						return fmt.Errorf("t.Cat: %w", err)
					}
					t.Cat = string(sval)
				}

				// t.Not ([]uint64) (slice)
			case "Not":
				{

					open, err := jr.ReadArrayOpenOrNull()
					if err != nil {
						return fmt.Errorf("t.Not: %w", err)
					}
					if open {

						close, err := jr.PeekArrayClose()
						if err != nil {
							return fmt.Errorf("t.Not: %w", err)
						}
						if close {
							if err := jr.ReadArrayClose(); err != nil {
								return fmt.Errorf("t.Not: %w", err)
							}

							t.Not = []uint64{}

						} else {
							for i := 0; i < 8192; i++ {
								item := make([]uint64, 1)
								{

									nval, err := jr.ReadNumberAsUint64()
									if err != nil {
										return fmt.Errorf("item[0]: %w", err)
									}
									item[0] = uint64(nval)

								}
								t.Not = append(t.Not, item[0])

								close, err := jr.ReadArrayCloseOrComma()
								if err != nil {
									return fmt.Errorf("t.Not: %w", err)
								}
								if close {
									break
								}
								if i == 8192-1 {
									return fmt.Errorf("t.Not: slice too large")
								}
							}
						}

					}

				}

				// t.Beep (int64) (int64)
			case "Beep":
				{

					nval, err := jr.ReadNumberAsInt64()
					if err != nil {
						return fmt.Errorf("t.Beep: %w", err)
					}
					t.Beep = int64(nval)

				}

				// t.Other ([]uint8) (slice)
			case "Other":

				{
					bval, err := jr.ReadBytes(2097152)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Other: byte array too large")
						}
						return fmt.Errorf("t.Other: %w", err)
					}
					if len(bval) > 0 {
						t.Other = []uint8(bval)
					}
				}

				// t.Stuff ([]uint64) (slice)
			case "Stuff":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.Stuff: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.Stuff: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.Stuff: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]uint64, 1)
							{

								nval, err := jr.ReadNumberAsUint64()
								if err != nil {
									return fmt.Errorf("item[0]: %w", err)
								}
								item[0] = uint64(nval)

							}
							t.Stuff = append(t.Stuff, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.Stuff: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.Stuff: slice too large")
							}
						}
					}

				}

				// t.NotOther ([]uint8) (slice)
			case "NotOther":

				{
					bval, err := jr.ReadBytesOrNull(2097152)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.NotOther: byte array too large")
						}
						return fmt.Errorf("t.NotOther: %w", err)
					}
					if bval != nil {
						t.NotOther = []uint8(*bval)
					}
				}

			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("TestSliceNilPreserve: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("TestSliceNilPreserve: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("TestSliceNilPreserve: map too large")
			}
		}
	}

	return nil
}
func (t *StringPtrSlices) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.Strings ([]string) (slice)
	if len("Strings") > 8192 {
		return fmt.Errorf("String in field \"Strings\" was too long")
	}
	if err := jw.WriteString(string("Strings")); err != nil {
		return fmt.Errorf("\"Strings\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Strings) > 8192 {
		return fmt.Errorf("Slice value in field t.Strings was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.Strings: %w", err)
	}
	for i, v := range t.Strings {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.Strings: %w", err)
			}
		}
		if len(v) > 8192 {
			return fmt.Errorf("String in field v was too long")
		}
		if err := jw.WriteString(string(v)); err != nil {
			return fmt.Errorf("v: %w", err)
		}
	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.Strings: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.StringPtrs ([]*string) (slice)
	if len("StringPtrs") > 8192 {
		return fmt.Errorf("String in field \"StringPtrs\" was too long")
	}
	if err := jw.WriteString(string("StringPtrs")); err != nil {
		return fmt.Errorf("\"StringPtrs\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.StringPtrs) > 8192 {
		return fmt.Errorf("Slice value in field t.StringPtrs was too long")
	}

	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("t.StringPtrs: %w", err)
	}
	for i, v := range t.StringPtrs {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("t.StringPtrs: %w", err)
			}
		}
		if v == nil {
			if err := jw.WriteNull(); err != nil {
				return fmt.Errorf("v: %w", err)
			}
		} else {
			if len(*v) > 8192 {
				return fmt.Errorf("String in field v was too long")
			}
			if err := jw.WriteString(string(*v)); err != nil {
				return fmt.Errorf("v: %w", err)
			}
		}
	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("t.StringPtrs: %w", err)
	}

	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *StringPtrSlices) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = StringPtrSlices{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("StringPtrSlices: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("StringPtrSlices: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("StringPtrSlices: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("StringPtrSlices: string too large")
				}
				return fmt.Errorf("StringPtrSlices: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("StringPtrSlices: %w", err)
			}
			switch name {

			// t.Strings ([]string) (slice)
			case "Strings":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.Strings: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.Strings: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.Strings: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]string, 1)
							{
								sval, err := jr.ReadString(8192)
								if err != nil {
									if errors.Is(err, jsg.ErrLimitExceeded) {
										return fmt.Errorf("item[0]: string too long")
									}
									return fmt.Errorf("item[0]: %w", err)
								}
								item[0] = string(sval)
							}
							t.Strings = append(t.Strings, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.Strings: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.Strings: slice too large")
							}
						}
					}

				}

				// t.StringPtrs ([]*string) (slice)
			case "StringPtrs":
				{

					if err := jr.ReadArrayOpen(); err != nil {
						return fmt.Errorf("t.StringPtrs: %w", err)
					}

					close, err := jr.PeekArrayClose()
					if err != nil {
						return fmt.Errorf("t.StringPtrs: %w", err)
					}
					if close {
						if err := jr.ReadArrayClose(); err != nil {
							return fmt.Errorf("t.StringPtrs: %w", err)
						}

					} else {
						for i := 0; i < 8192; i++ {
							item := make([]*string, 1)
							{
								sval, err := jr.ReadStringOrNull(8192)
								if err != nil {
									if errors.Is(err, jsg.ErrLimitExceeded) {
										return fmt.Errorf("item[0]: string too long")
									}
									return fmt.Errorf("item[0]: %w", err)
								}
								if sval != nil {
									item[0] = (*string)(sval)
								}
							}
							t.StringPtrs = append(t.StringPtrs, item[0])

							close, err := jr.ReadArrayCloseOrComma()
							if err != nil {
								return fmt.Errorf("t.StringPtrs: %w", err)
							}
							if close {
								break
							}
							if i == 8192-1 {
								return fmt.Errorf("t.StringPtrs: slice too large")
							}
						}
					}

				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("StringPtrSlices: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("StringPtrSlices: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("StringPtrSlices: map too large")
			}
		}
	}

	return nil
}
func (t *FieldNameOverlap) MarshalDagJSON(w io.Writer) error {
	jw := jsg.NewDagJsonWriter(w)
	if t == nil {
		err := jw.WriteNull()
		return err
	}
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}
	written := 0

	// t.Foo (int64) (int64)
	if len("foo") > 8192 {
		return fmt.Errorf("String in field \"foo\" was too long")
	}
	if err := jw.WriteString(string("foo")); err != nil {
		return fmt.Errorf("\"foo\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}

	if err := jw.WriteInt64(int64(t.Foo)); err != nil {
		return fmt.Errorf("t.Foo: %w", err)
	}

	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.Bar (string) (string)
	if len("beep") > 8192 {
		return fmt.Errorf("String in field \"beep\" was too long")
	}
	if err := jw.WriteString(string("beep")); err != nil {
		return fmt.Errorf("\"beep\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.Bar) > 8192 {
		return fmt.Errorf("String in field t.Bar was too long")
	}
	if err := jw.WriteString(string(t.Bar)); err != nil {
		return fmt.Errorf("t.Bar: %w", err)
	}
	written++
	if written > 0 {
		if err := jw.WriteComma(); err != nil {
			return err
		}
	}

	// t.LongerNamedField (string) (string)
	if len("LongerNamedField") > 8192 {
		return fmt.Errorf("String in field \"LongerNamedField\" was too long")
	}
	if err := jw.WriteString(string("LongerNamedField")); err != nil {
		return fmt.Errorf("\"LongerNamedField\": %w", err)
	}
	if err := jw.WriteObjectColon(); err != nil {
		return err
	}
	if len(t.LongerNamedField) > 8192 {
		return fmt.Errorf("String in field t.LongerNamedField was too long")
	}
	if err := jw.WriteString(string(t.LongerNamedField)); err != nil {
		return fmt.Errorf("t.LongerNamedField: %w", err)
	}
	written++
	if err := jw.WriteObjectClose(); err != nil {
		return err
	}
	return nil
}
func (t *FieldNameOverlap) UnmarshalDagJSON(r io.Reader) (err error) {
	*t = FieldNameOverlap{}

	jr := jsg.NewDagJsonReader(r)
	defer func() {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
	}()
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("FieldNameOverlap: %w", err)
	}
	close, err := jr.PeekObjectClose()
	if err != nil {
		return fmt.Errorf("FieldNameOverlap: %w", err)
	}
	if close {
		if err := jr.ReadObjectClose(); err != nil {
			return fmt.Errorf("FieldNameOverlap: %w", err)
		}
	} else {
		for i := uint64(0); i < 8192; i++ {
			name, err := jr.ReadString(8192)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("FieldNameOverlap: string too large")
				}
				return fmt.Errorf("FieldNameOverlap: %w", err)
			}
			if err := jr.ReadObjectColon(); err != nil {
				return fmt.Errorf("FieldNameOverlap: %w", err)
			}
			switch name {

			// t.Foo (int64) (int64)
			case "foo":
				{

					nval, err := jr.ReadNumberAsInt64()
					if err != nil {
						return fmt.Errorf("t.Foo: %w", err)
					}
					t.Foo = int64(nval)

				}

				// t.Bar (string) (string)
			case "beep":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.Bar: string too long")
						}
						return fmt.Errorf("t.Bar: %w", err)
					}
					t.Bar = string(sval)
				}

				// t.LongerNamedField (string) (string)
			case "LongerNamedField":
				{
					sval, err := jr.ReadString(8192)
					if err != nil {
						if errors.Is(err, jsg.ErrLimitExceeded) {
							return fmt.Errorf("t.LongerNamedField: string too long")
						}
						return fmt.Errorf("t.LongerNamedField: %w", err)
					}
					t.LongerNamedField = string(sval)
				}
			default:
				// Field doesn't exist on this type, so ignore it
				if err := jr.DiscardType(); err != nil {
					return fmt.Errorf("FieldNameOverlap: ignoring field %s: %w", name, err)
				}
			}

			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("FieldNameOverlap: %w", err)
			}
			if close {
				break
			}
			if i == 8192-1 {
				return fmt.Errorf("FieldNameOverlap: map too large")
			}
		}
	}

	return nil
}
