package typegen

import (
	"fmt"
	"io"
	"math/big"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"text/template"

	cid "github.com/ipfs/go-cid"
)

const (
	MaxLength       = 8192
	ByteArrayMaxLen = 2 << 20
	NoUsrMaxLen     = -1
)

var (
	cidType      = reflect.TypeOf(cid.Cid{})
	bigIntType   = reflect.TypeOf(big.Int{})
	deferredType = reflect.TypeOf(Deferred{})
)

// Gen is a configurable code generator for DAG JSON types. Use this instead of
// the convenience functions to have more control over the generated code.
type Gen struct {
	MaxArrayLength  int // Default: 8192 (MaxLength)
	MaxByteLength   int // Default: 2<<20 (ByteArrayMaxLen)
	MaxStringLength int // Default: 8192 (MaxLength)

	// Write output file in order of type names
	SortTypeNames bool
}

func (g Gen) maxArrayLength() int {
	if g.MaxArrayLength == 0 {
		return MaxLength
	}
	return g.MaxArrayLength
}

func (g Gen) maxByteLength() int {
	if g.MaxByteLength == 0 {
		return ByteArrayMaxLen
	}
	return g.MaxByteLength
}

func (g Gen) maxStringLength() int {
	if g.MaxStringLength == 0 {
		return MaxLength
	}
	return g.MaxStringLength
}

func (g Gen) doTemplate(w io.Writer, info interface{}, templ string) error {
	t := template.Must(template.New("").
		Funcs(template.FuncMap{
			"MaxLen": func(val int, defaultType string) string {
				if val <= 0 {
					switch defaultType {
					case "Bytes":
						val = g.maxByteLength()
					case "Array":
						val = g.maxArrayLength()
					case "String":
						val = g.maxStringLength()
					default:
						panic(fmt.Sprintf("error: unknown property [%s]", defaultType))
					}
				}
				return fmt.Sprintf("%d", val)
			},
		}).Parse(templ))

	return t.Execute(w, info)
}

// PrintHeaderAndUtilityMethods is a convenience wrapper around Gen.PrintHeaderAndUtilityMethods
// using default options.
func PrintHeaderAndUtilityMethods(w io.Writer, pkg string, typeInfos []*GenTypeInfo) error {
	return Gen{}.PrintHeaderAndUtilityMethods(w, pkg, typeInfos)
}

func (g Gen) PrintHeaderAndUtilityMethods(w io.Writer, pkg string, typeInfos []*GenTypeInfo) error {
	var imports []Import
	for _, gti := range typeInfos {
		imports = append(imports, gti.Imports()...)
	}

	imports = append(imports, defaultImports...)
	imports = dedupImports(imports)

	data := struct {
		Package string
		Imports []Import
	}{pkg, imports}
	return g.doTemplate(w, data, `// Code generated by github.com/alanshaw/dag-json-gen. DO NOT EDIT.

package {{ .Package }}

import (
	"errors"
	"fmt"
	"io"
	"math"
	"sort"

{{ range .Imports }}{{ .Name }} "{{ .PkgPath }}"
{{ end }}
)

var _ = cid.Undef
var _ = math.E
var _ = sort.Sort
var _ = errors.Is

`)
}

// FieldNameSelf is the name of the field that is the marshal target itself.
// This is used in non-struct types which are handled like transparent structs.
const FieldNameSelf = "."

type Field struct {
	Name    string
	MapKey  string
	Pointer bool
	Type    reflect.Type
	Pkg     string
	Const   *string

	OmitEmpty   bool
	Optional    bool
	PreserveNil bool
	IterLabel   string

	MaxLen int
}

func typeName(pkg string, t reflect.Type) string {
	switch t.Kind() {
	case reflect.Array:
		return fmt.Sprintf("[%d]%s", t.Len(), typeName(pkg, t.Elem()))
	case reflect.Slice:
		return "[]" + typeName(pkg, t.Elem())
	case reflect.Ptr:
		return "*" + typeName(pkg, t.Elem())
	case reflect.Map:
		return "map[" + typeName(pkg, t.Key()) + "]" + typeName(pkg, t.Elem())
	default:
		pkgPath := t.PkgPath()
		switch pkgPath {
		case "":
			// It's a built-in.
			return t.String()
		case pkg:
			return t.Name()
		}
		return fmt.Sprintf("%s.%s", resolvePkgName(pkgPath, t.String()), t.Name())
	}
}

func (f Field) TypeName() string {
	return typeName(f.Pkg, f.Type)
}

func (f Field) ElemName() string {
	return typeName(f.Pkg, f.Type.Elem())
}

func (f Field) IsArray() bool {
	return f.Type.Kind() == reflect.Array
}

func (f Field) EmptyVal() (string, error) {
	return emptyValForField(f)
}

func (f Field) Len() int {
	return f.Type.Len()
}

type GenTypeInfo struct {
	Name                string
	Fields              []Field
	MandatoryFieldCount int
	Transparent         bool
}

func (gti *GenTypeInfo) Imports() []Import {
	var imports []Import
	for _, f := range gti.Fields {
		switch f.Type.Kind() {
		case reflect.Struct:
			if f.Type == bigIntType {
				continue
			}
			if f.Type == cidType {
				continue
			}
		case reflect.Bool:
			continue
		}
		imports = append(imports, ImportsForType(f.Pkg, f.Type)...)
	}
	return imports
}

func (gti *GenTypeInfo) MaxMapKeyLength() int {
	var mlen int
	for _, f := range gti.Fields {
		if len(f.MapKey) > mlen {
			mlen = len(f.MapKey)
		}
	}
	return mlen
}

func nameIsExported(name string) bool {
	return strings.ToUpper(name[0:1]) == name[0:1]
}

func ParseTypeInfo(itype interface{}) (*GenTypeInfo, error) {
	// If we're handed *Foo instead of value Foo, deref the pointer.
	// ParseTypeInfo is only every handed a top level type, so this shouldn't violate any expectations.
	iv := reflect.ValueOf(itype)
	switch iv.Kind() {
	case reflect.Pointer, reflect.Interface:
		iv = iv.Elem()
	default:
	}
	t := iv.Type()

	pkg := t.PkgPath()

	out := GenTypeInfo{
		Name:        t.Name(),
		Transparent: false,
	}

	if t.Kind() != reflect.Struct {
		return &GenTypeInfo{
			Name:        t.Name(),
			Transparent: true,
			Fields: []Field{
				{
					Name:        FieldNameSelf,
					MapKey:      "",
					Pointer:     t.Kind() == reflect.Ptr,
					Type:        t,
					Pkg:         pkg,
					Const:       nil,
					OmitEmpty:   false,
					PreserveNil: false,
					IterLabel:   "",
					MaxLen:      NoUsrMaxLen,
				},
			},
		}, nil
	}

	for i := 0; i < t.NumField(); i++ {
		if out.Transparent {
			return nil, fmt.Errorf("transparent structs must have exactly one field")
		}

		f := t.Field(i)
		if !nameIsExported(f.Name) {
			continue
		}

		ft := f.Type
		var pointer bool
		if ft.Kind() == reflect.Ptr {
			ft = ft.Elem()
			pointer = true
		}

		mapk := f.Name
		usrMaxLen := NoUsrMaxLen
		tagval := f.Tag.Get("dagjsongen")
		tags, err := tagparse(tagval)
		if err != nil {
			return nil, fmt.Errorf("invalid tag format: %w", err)
		}

		if _, ok := tags["ignore"]; ok {
			continue
		}

		if tags["name"] != "" {
			mapk = tags["name"]
		}
		if msize := tags["maxlen"]; msize != "" {
			val, err := strconv.Atoi(msize)
			if err != nil {
				return nil, fmt.Errorf("maxsize tag value was not valid: %w", err)
			}

			usrMaxLen = val
		}

		var constval *string
		if cv, hasconst := tags["const"]; hasconst {
			if ft.Kind() != reflect.String {
				return nil, fmt.Errorf("const vals are only supported for string types")
			}
			constval = &cv
		}

		_, transparent := tags["transparent"]
		if transparent && len(out.Fields) > 0 {
			return nil, fmt.Errorf("only one transparent field is allowed")
		}
		out.Transparent = transparent

		_, omitempty := tags["omitempty"]
		_, optional := tags["optional"]
		_, preservenil := tags["preservenil"]

		if preservenil && ft.Kind() != reflect.Slice {
			return nil, fmt.Errorf("%T.%s: preservenil is only supported on slice types", itype, f.Name)
		}

		out.Fields = append(out.Fields, Field{
			Name:        f.Name,
			MapKey:      mapk,
			Pointer:     pointer,
			Type:        ft,
			Pkg:         pkg,
			OmitEmpty:   omitempty,
			PreserveNil: preservenil,
			MaxLen:      usrMaxLen,
			Const:       constval,
			Optional:    optional,
		})
	}

	for i, field := range out.Fields {
		if field.Optional {
			continue
		}
		if out.MandatoryFieldCount != i {
			return nil, fmt.Errorf("mandatory field %T.%s cannot come after optional fields", itype, field.Name)
		}
		out.MandatoryFieldCount++
	}

	return &out, nil
}

func tagparse(v string) (map[string]string, error) {
	out := make(map[string]string)
	for _, elem := range strings.Split(v, ",") {
		elem = strings.TrimSpace(elem)
		if elem == "" {
			continue
		}
		if strings.Contains(elem, "=") {
			parts := strings.Split(elem, "=")
			if len(parts) != 2 {
				return nil, fmt.Errorf("struct tags with params must be of form X=Y")
			}
			out[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])
		} else if elem == "omitempty" {
			out["omitempty"] = "true"
		} else if elem == "preservenil" {
			out["preservenil"] = "true"
		} else if elem == "ignore" || elem == "-" {
			out["ignore"] = "true"
		} else if elem == "transparent" {
			out["transparent"] = "true"
		} else if elem == "optional" {
			out["optional"] = "true"
		} else {
			out["name"] = elem
		}
	}
	return out, nil
}

func (g Gen) emitDagJsonMarshalStringField(w io.Writer, f Field) error {
	if f.Pointer {
		return g.doTemplate(w, f, `
		if {{ .Name }} == nil {
			if err := jw.WriteNull(); err != nil {
				return fmt.Errorf("{{ .Name | js }}: %w", err)
			}
		} else {
			if len(*{{ .Name }}) > {{ MaxLen .MaxLen "String" }} {
				return fmt.Errorf("String in field {{ .Name | js }} was too long")
			}
			if err := jw.WriteString(string(*{{ .Name }})); err != nil {
				return fmt.Errorf("{{ .Name | js }}: %w", err)
			}
		}`)
	}

	if f.Const != nil {
		return g.doTemplate(w, f, `
		if err := jw.WriteString("{{ .Const }}"); err != nil {
			return err
		}`)
	}

	return g.doTemplate(w, f, `
	if len({{ .Name }}) > {{ MaxLen .MaxLen "String" }} {
		return fmt.Errorf("String in field {{ .Name | js }} was too long")
	}
	if err := jw.WriteString(string({{ .Name }})); err != nil {
		return fmt.Errorf("{{ .Name | js }}: %w", err)
	}`)
}

func (g Gen) emitDagJsonMarshalStructField(w io.Writer, f Field) error {
	switch f.Type {
	case bigIntType:
		return g.doTemplate(w, f, `
		if {{ .Name }} != nil && {{ .Name }}.Sign() < 0 {
			return fmt.Errorf("Value in field {{ .Name | js }} was a negative big-integer (not supported)")
		}
		if {{ .Name }} == nil {
			if err := jw.WriteUint8(0); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		} else {
			if err := jw.WriteBigInt({{ .Name }}); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		}`)

	case cidType:
		return g.doTemplate(w, f, `
		{{ if .Pointer }}
			if {{ .Name }} == nil {
				if err := jw.WriteNull(); err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
			} else {
				if err := jw.WriteCid(*{{ .Name }}); err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
			}
		{{ else }}
			if err := jw.WriteCid({{ .Name }}); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		{{ end }}`)
	default:
		return g.doTemplate(w, f, `
		if err := {{ .Name }}.MarshalDagJSON(jw); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}`)
	}
}

func (g Gen) emitDagJsonMarshalUint64Field(w io.Writer, f Field) error {
	return g.doTemplate(w, f, `
	{{ if .Pointer }}
		if {{ .Name }} == nil {
			if err := jw.WriteNull(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		} else {
			if err := jw.WriteUint64(uint64(*{{ .Name }})); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		}
	{{ else }}
		if err := jw.WriteUint64(uint64({{ .Name }})); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
	{{ end }}`)
}

func (g Gen) emitDagJsonMarshalUint8Field(w io.Writer, f Field) error {
	if f.Pointer {
		return fmt.Errorf("pointers to integers not supported")
	}
	return g.doTemplate(w, f, `
	if err := jw.WriteUint8(uint8({{ .Name }})); err != nil {
		return fmt.Errorf("{{ .Name }}: %w", err)
	}`)
}

func (g Gen) emitDagJsonMarshalInt64Field(w io.Writer, f Field) error {
	return g.doTemplate(w, f, `
	{{ if .Pointer }}
		if {{ .Name }} == nil {
			if err := jw.WriteNull(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		} else {
			if err := jw.WriteInt64(int64(*{{ .Name }})); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		}
	{{ else }}
		if err := jw.WriteInt64(int64({{ .Name }})); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
	{{ end }}`)
}

func (g Gen) emitDagJsonMarshalBoolField(w io.Writer, f Field) error {
	if f.Pointer {
		return g.doTemplate(w, f, `
		if {{ .Name }} == nil {
			if err := jw.WriteNull(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		} else {
			if err := jw.WriteBool(*{{ .Name }}); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		}`)
	} else {
		return g.doTemplate(w, f, `
		if err := jw.WriteBool({{ .Name }}); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}`)
	}
}

func (g Gen) emitDagJsonMarshalMapField(w io.Writer, f Field) error {
	err := g.doTemplate(w, f, `
	{
		if len({{ .Name }}) > 4096 {
			return fmt.Errorf("cannot marshal {{ .Name }} map too large")
		}

		if err := jw.WriteObjectOpen(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}

		keys := make([]string, 0, len({{ .Name }}))
		for k := range {{ .Name }} {
			keys = append(keys, k)
		}
		sort.Strings(keys)
		for i, k := range keys {
			if i > 0 {
				if err := jw.WriteComma(); err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
			}
			v := {{ .Name }}[k]`)
	if err != nil {
		return err
	}

	// Map key
	switch f.Type.Key().Kind() {
	case reflect.String:
		if err := g.emitDagJsonMarshalStringField(w, Field{Name: "k"}); err != nil {
			return err
		}
		if err := g.doTemplate(w, f, `
			if err := jw.WriteObjectColon(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		`); err != nil {
			return err
		}
	default:
		return fmt.Errorf("non-string map keys are not yet supported")
	}

	// Map value
	switch f.Type.Elem().Kind() {
	case reflect.String:
		if err := g.emitDagJsonMarshalStringField(w, Field{Name: "v"}); err != nil {
			return err
		}
	case reflect.Ptr:
		if f.Type.Elem().Elem().Kind() != reflect.Struct {
			return fmt.Errorf("unsupported map elem ptr type: %s", f.Type.Elem())
		}

		fallthrough
	case reflect.Struct:
		if err := g.emitDagJsonMarshalStructField(w, Field{Name: "v", Type: f.Type.Elem(), Pkg: f.Pkg}); err != nil {
			return err
		}
	default:
		return fmt.Errorf("currently unsupported map elem type: %s", f.Type.Elem())
	}

	return g.doTemplate(w, f, `
		}
		if err := jw.WriteObjectClose(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
	}
	`)
}

func (g Gen) emitDagJsonMarshalSliceField(w io.Writer, f Field) error {
	if f.Pointer {
		return fmt.Errorf("pointers to slices not supported")
	}
	e := f.Type.Elem()

	if e.Kind() == reflect.Uint8 {
		return g.doTemplate(w, f, `
		if len({{ .Name }}) > {{ MaxLen .MaxLen "Bytes" }} {
			return fmt.Errorf("Byte array in field {{ .Name }} was too long")
		}
		{{ if .PreserveNil }}
		if {{ .Name }} == nil {
			if err := jw.WriteNull(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		} else {
		{{ end }}
			if err := jw.WriteBytes({{ .Name }}); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		{{ if .PreserveNil }}
		}
		{{ end }}`)
	}

	var pointer bool
	if e.Kind() == reflect.Ptr {
		e = e.Elem()
		pointer = true
	}

	err := g.doTemplate(w, f, `
	if len({{ .Name }}) > {{ MaxLen .MaxLen "Array" }} {
		return fmt.Errorf("Slice value in field {{ .Name }} was too long")
	}
	{{ if .PreserveNil }}
	if {{ .Name }} == nil {
		if err := jw.WriteNull(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
	} else {
	{{ end }}
		if err := jw.WriteArrayOpen(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		for i, v := range {{ .Name }} {
			if i > 0 {
				if err := jw.WriteComma(); err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
			}`)
	if err != nil {
		return err
	}

	subf := Field{Name: "v", Type: e, Pkg: f.Pkg, Pointer: pointer}
	switch e.Kind() {
	default:
		err = fmt.Errorf("do not yet support slices of %s yet", e.Kind())
	case reflect.Struct:
		err = g.emitDagJsonMarshalStructField(w, subf)
	case reflect.Uint64:
		err = g.emitDagJsonMarshalUint64Field(w, subf)
	case reflect.Uint8:
		err = g.emitDagJsonMarshalUint8Field(w, subf)
	case reflect.Int64:
		err = g.emitDagJsonMarshalInt64Field(w, subf)
	case reflect.Slice:
		err = g.emitDagJsonMarshalSliceField(w, subf)
	case reflect.String:
		err = g.emitDagJsonMarshalStringField(w, subf)
	}
	if err != nil {
		return err
	}

	// array end
	if err := g.doTemplate(w, f, `
		}
		if err := jw.WriteArrayClose(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
	{{ if .PreserveNil }}
	}
	{{ end }}`); err != nil {
		return err
	}

	return nil
}

func (g Gen) emitDagJsonMarshalArrayField(w io.Writer, f Field) error {
	if f.Pointer {
		return fmt.Errorf("pointers to arrays not supported")
	}
	e := f.Type.Elem()

	// Note: this re-slices the slice to deal with arrays.
	if e.Kind() == reflect.Uint8 {
		return g.doTemplate(w, f, `
		if len({{ .Name }}) > {{ MaxLen .MaxLen "Bytes" }} {
			return fmt.Errorf("Byte array in field {{ .Name }} was too long")
		}
		if err := jw.WriteBytes({{ .Name }}[:]); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}`)
	}

	var pointer bool
	if e.Kind() == reflect.Ptr {
		e = e.Elem()
		pointer = true
	}

	err := g.doTemplate(w, f, `
	if len({{ .Name }}) > {{ MaxLen .MaxLen "Array" }} {
		return fmt.Errorf("Slice value in field {{ .Name }} was too long")
	}
	if err := jw.WriteArrayOpen(); err != nil {
		return fmt.Errorf("{{ .Name }}: %w", err)
	}
	for i, v := range {{ .Name }} {
		if i > 0 {
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		}`)
	if err != nil {
		return err
	}

	subf := Field{Name: "v", Type: e, Pkg: f.Pkg, Pointer: pointer}
	switch e.Kind() {
	default:
		err = fmt.Errorf("do not yet support arrays of %s yet", e.Kind())
	case reflect.Struct:
		err = g.emitDagJsonMarshalStructField(w, subf)
	case reflect.Uint64:
		err = g.emitDagJsonMarshalUint64Field(w, subf)
	case reflect.Uint8:
		err = g.emitDagJsonMarshalUint8Field(w, subf)
	case reflect.Int64:
		err = g.emitDagJsonMarshalInt64Field(w, subf)
	case reflect.Slice:
		err = g.emitDagJsonMarshalSliceField(w, subf)
	case reflect.String:
		err = g.emitDagJsonMarshalStringField(w, subf)
	}
	if err != nil {
		return err
	}

	// array end
	return g.doTemplate(w, f, `
	}
	if err := jw.WriteArrayClose(); err != nil {
		return fmt.Errorf("{{ .Name }}: %w", err)
	}`)
}

func (g Gen) emitDagJsonMarshalStructTuple(w io.Writer, gti *GenTypeInfo) (err error) {
	if gti.Transparent {
		err = g.doTemplate(w, gti, `
		func (t *{{ .Name }}) MarshalDagJSON(w io.Writer) error {
			jw := jsg.NewDagJsonWriter(w)`)
	} else {
		err = g.doTemplate(w, gti, `
		func (t *{{ .Name }}) MarshalDagJSON(w io.Writer) error {
			jw := jsg.NewDagJsonWriter(w)
			if t == nil {
				err := jw.WriteNull()
				return err
			}
			if err := jw.WriteArrayOpen(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}`)
	}
	if err != nil {
		return err
	}

	for i, f := range gti.Fields {
		if i > 0 {
			if err := g.doTemplate(w, f, `
			if err := jw.WriteComma(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}`); err != nil {
				return err
			}
		}
		if f.Name == FieldNameSelf {
			f.Name = "(*t)"
		} else {
			f.Name = "t." + f.Name
		}
		if _, err := fmt.Fprintf(w, "\n\n\t// %s (%s) (%s)", f.Name, f.Type, f.Type.Kind()); err != nil {
			return err
		}

		switch f.Type.Kind() {
		case reflect.String:
			if err := g.emitDagJsonMarshalStringField(w, f); err != nil {
				return err
			}
		case reflect.Struct:
			if err := g.emitDagJsonMarshalStructField(w, f); err != nil {
				return err
			}
		case reflect.Uint64:
			if err := g.emitDagJsonMarshalUint64Field(w, f); err != nil {
				return err
			}
		case reflect.Uint8:
			if err := g.emitDagJsonMarshalUint8Field(w, f); err != nil {
				return err
			}
		case reflect.Int64:
			if err := g.emitDagJsonMarshalInt64Field(w, f); err != nil {
				return err
			}
		case reflect.Array:
			if err := g.emitDagJsonMarshalArrayField(w, f); err != nil {
				return err
			}
		case reflect.Slice:
			if err := g.emitDagJsonMarshalSliceField(w, f); err != nil {
				return err
			}
		case reflect.Bool:
			if err := g.emitDagJsonMarshalBoolField(w, f); err != nil {
				return err
			}
		case reflect.Map:
			if err := g.emitDagJsonMarshalMapField(w, f); err != nil {
				return err
			}
		default:
			return fmt.Errorf("field %q of %q has unsupported kind %q", f.Name, gti.Name, f.Type.Kind())
		}
	}

	if !gti.Transparent {
		if err := g.doTemplate(w, gti, `
		if err := jw.WriteArrayClose(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}`); err != nil {
			return err
		}
	}

	_, err = fmt.Fprintf(w, "\n\treturn nil\n}\n\n")
	return err
}

func (g Gen) emitDagJsonUnmarshalStringField(w io.Writer, f Field) error {
	if f.Pointer {
		return g.doTemplate(w, f, `
		{
			sval, err := jr.ReadStringOrNull({{ MaxLen 0 "String" }})
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("{{ .Name }}: string too long")
				}
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if sval != nil {
				{{ .Name }} = (*{{ .TypeName }})(sval)
			}
		}`)
	}
	if f.Type == nil {
		f.Type = reflect.TypeOf("")
	}
	return g.doTemplate(w, f, `
	{
		sval, err := jr.ReadString({{ MaxLen 0 "String" }})
		if err != nil {
			if errors.Is(err, jsg.ErrLimitExceeded) {
				return fmt.Errorf("{{ .Name }}: string too long")
			}
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		{{ .Name }} = {{ .TypeName }}(sval)
	}`)
}

func (g Gen) emitDagJsonUnmarshalStructField(w io.Writer, f Field) error {
	switch f.Type {
	case bigIntType:
		return g.doTemplate(w, f, `
		{
			nval, err := jr.ReadNumberAsBigInt(256)
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("{{ .Name }}: number too large")
				}
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			{{ .Name }} = nval
		}`)
	case cidType:
		return g.doTemplate(w, f, `
		{
			{{ if .Pointer }}
				c, err := jr.ReadCidOrNull()
				if err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
				{{ .Name }} = c
			{{ else }}
				c, err := jr.ReadCid()
				if err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
				{{ .Name }} = c
			{{ end }}
		}`)
	case deferredType:
		return g.doTemplate(w, f, `
		{{ if .Pointer }}
			{{ .Name }} = new(jsg.Deferred)
		{{ end }}
		if err := {{ .Name }}.UnmarshalDagJSON(jr); err != nil {
			return fmt.Errorf("failed to read deferred field: %w", err)
		}`)
	default:
		return g.doTemplate(w, f, `
		{{ if .Pointer }}
			{
				null, err := jr.PeekNull()
				if err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
				if null {
					if err := jr.ReadNull(); err != nil {
						return fmt.Errorf("{{ .Name }}: %w", err)
					}
				} else {
					{{ .Name }} = new({{ .TypeName }})
					if err := {{ .Name }}.UnmarshalDagJSON(jr); err != nil {
						return fmt.Errorf("unmarshaling {{ .Name }} pointer: %w", err)
					}
				}
			}
		{{ else }}
			if err := {{ .Name }}.UnmarshalDagJSON(jr); err != nil {
				return fmt.Errorf("unmarshaling {{ .Name }}: %w", err)
			}
		{{ end }}`)
	}
}

func (g Gen) emitDagJsonUnmarshalInt64Field(w io.Writer, f Field) error {
	return g.doTemplate(w, f, `
	{
		{{ if .Pointer }}
			nval, err := jr.ReadNumberAsInt64OrNull()
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if nval != nil {
				typed := {{ .TypeName }}(*nval)
				{{ .Name }} = &typed
			}
		{{ else }}
			nval, err := jr.ReadNumberAsInt64()
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			{{ .Name }} = {{ .TypeName }}(nval)
		{{ end }}
	}`)
}

func (g Gen) emitDagJsonUnmarshalUint64Field(w io.Writer, f Field) error {
	return g.doTemplate(w, f, `
	{
		{{ if .Pointer }}
			nval, err := jr.ReadNumberAsUint64OrNull()
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if nval != nil {
				typed := {{ .TypeName }}(*nval)
				{{ .Name }} = &typed
			}
		{{ else }}
			nval, err := jr.ReadNumberAsUint64()
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			{{ .Name }} = {{ .TypeName }}(nval)
		{{ end }}
	}`)
}

func (g Gen) emitDagJsonUnmarshalUint8Field(w io.Writer, f Field) error {
	return g.doTemplate(w, f, `
	{
		nval, err := jr.ReadNumberAsUint8()
		if err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		{{ .Name }} = {{ .TypeName }}(nval)
	}`)
}

func (g Gen) emitDagJsonUnmarshalBoolField(w io.Writer, f Field) error {
	if f.Pointer {
		return g.doTemplate(w, f, `
		{
			bval, err := jr.ReadBoolOrNull()
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if bval != nil {
				{{ .Name }} = bval
			}
		}`)
	} else {
		return g.doTemplate(w, f, `
		bval, err := jr.ReadBool()
		if err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		{{ .Name }} = bval`)
	}
}

func (g Gen) emitDagJsonUnmarshalMapField(w io.Writer, f Field) error {
	err := g.doTemplate(w, f, `
	if err := jr.ReadObjectOpen(); err != nil {
		return fmt.Errorf("{{ .Name }}: %w", err)
	}

	{{ .Name }} = {{ .TypeName }}{}

	close, err := jr.PeekObjectClose()
		if err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		if close {
			if err := jr.ReadObjectClose(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		} else {
			for i, l := 0, {{ MaxLen .MaxLen "Array" }}; i < l; i++ {`)
	if err != nil {
		return err
	}

	switch f.Type.Key().Kind() {
	case reflect.String:
		if err := g.doTemplate(w, f, `
		var k string`); err != nil {
			return err
		}
		if err := g.emitDagJsonUnmarshalStringField(w, Field{Name: "k"}); err != nil {
			return err
		}
	default:
		return fmt.Errorf("maps with non-string keys are not supported")
	}

	if err := g.doTemplate(w, f, `
		if err := jr.ReadObjectColon(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}`); err != nil {
		return err
	}

	var pointer bool
	t := f.Type.Elem()
	switch t.Kind() {
	case reflect.String:
		if err := g.doTemplate(w, f, `
		var v string`); err != nil {
			return err
		}
		if err := g.emitDagJsonUnmarshalStringField(w, Field{Name: "v"}); err != nil {
			return err
		}
		if err := g.doTemplate(w, f, `
		{{ .Name }}[k] = v`); err != nil {
			return err
		}
	case reflect.Ptr:
		if t.Elem().Kind() != reflect.Struct {
			return fmt.Errorf("unsupported map elem ptr type: %s", t)
		}

		pointer = true
		fallthrough
	case reflect.Struct:
		subf := Field{Name: "v", Pointer: pointer, Type: t, Pkg: f.Pkg}
		if err := g.doTemplate(w, subf, `
		var v {{ .TypeName }}`); err != nil {
			return err
		}

		if pointer {
			subf.Type = subf.Type.Elem()
		}
		if err := g.emitDagJsonUnmarshalStructField(w, subf); err != nil {
			return err
		}
		if err := g.doTemplate(w, f, `
		{{ .Name }}[k] = v`); err != nil {
			return err
		}
	default:
		return fmt.Errorf("currently only support maps of structs")
	}

	return g.doTemplate(w, f, `
			close, err := jr.ReadObjectCloseOrComma()
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if close {
				break
			}
		}
	}`)
}

func (g Gen) emitDagJsonUnmarshalSliceField(w io.Writer, f Field) error {
	if f.IterLabel == "" {
		f.IterLabel = "i"
	}

	e := f.Type.Elem()
	var pointer bool
	if e.Kind() == reflect.Ptr {
		pointer = true
		e = e.Elem()
	}

	if e.Kind() == reflect.Uint8 {
		return g.doTemplate(w, f, `
		{{ if .PreserveNil }}
		{
			bval, err := jr.ReadBytesOrNull({{ MaxLen .MaxLen "Bytes" }})
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("{{ .Name }}: byte array too large")
				}
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if bval != nil {
				{{ .Name }} = {{ .TypeName }}(*bval)
			}
		}
		{{ else }}
		{
			bval, err := jr.ReadBytes({{ MaxLen .MaxLen "Bytes" }})
			if err != nil {
				if errors.Is(err, jsg.ErrLimitExceeded) {
					return fmt.Errorf("{{ .Name }}: byte array too large")
				}
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if len(bval) > 0 {
				{{ .Name }} = {{ .TypeName }}(bval)
			}
		}
		{{ end }}`)
	}

	err := g.doTemplate(w, f, `
	{
		{{ if .PreserveNil }}
			open, err := jr.ReadArrayOpenOrNull()
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if open {
		{{ else }}
		if err := jr.ReadArrayOpen(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		{{ end }}
		close, err := jr.PeekArrayClose()
		if err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		if close {
			if err := jr.ReadArrayClose(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			{{ if .PreserveNil }}
				{{ .Name }} = {{ .TypeName }}{}
			{{ end }}
		} else {`)
	if err != nil {
		return err
	}

	err = g.doTemplate(w, f, `
	for {{ .IterLabel }} := 0; {{ .IterLabel }} < {{ MaxLen .MaxLen "Array" }}; {{ .IterLabel }}++ {
		item := make({{ .TypeName }}, 1)`)
	if err != nil {
		return err
	}

	switch e.Kind() {
	case reflect.Struct:
		subf := Field{
			Type:    e,
			Pkg:     f.Pkg,
			Pointer: pointer,
			Name:    "item[0]",
		}
		err := g.emitDagJsonUnmarshalStructField(w, subf)
		if err != nil {
			return err
		}
	case reflect.Uint64:
		subf := Field{
			Type: e,
			Pkg:  f.Pkg,
			Name: "item[0]",
		}
		err := g.emitDagJsonUnmarshalUint64Field(w, subf)
		if err != nil {
			return err
		}
	case reflect.Int64:
		subf := Field{
			Type: e,
			Pkg:  f.Pkg,
			Name: "item[0]",
		}
		err := g.emitDagJsonUnmarshalInt64Field(w, subf)
		if err != nil {
			return err
		}
	case reflect.Array:
		nextIter := string([]byte{f.IterLabel[0] + 1})
		subf := Field{
			Name:      "item[0]",
			Type:      e,
			IterLabel: nextIter,
			Pkg:       f.Pkg,
		}
		if err := g.emitDagJsonUnmarshalArrayField(w, subf); err != nil {
			return err
		}
	case reflect.Slice:
		nextIter := string([]byte{f.IterLabel[0] + 1})
		subf := Field{
			Name:      "item[0]",
			Type:      e,
			IterLabel: nextIter,
			Pkg:       f.Pkg,
		}
		if err := g.emitDagJsonUnmarshalSliceField(w, subf); err != nil {
			return err
		}

	case reflect.String:
		subf := Field{
			Type:    e,
			Pkg:     f.Pkg,
			Pointer: pointer,
			Name:    "item[0]",
		}
		err := g.emitDagJsonUnmarshalStringField(w, subf)
		if err != nil {
			return err
		}

	default:
		return fmt.Errorf("do not yet support slices of %s yet", e.Elem())
	}

	if err := g.doTemplate(w, f, `
				{{ .Name }} = append({{ .Name }}, item[0])

				close, err := jr.ReadArrayCloseOrComma()
				if err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
				if close {
					break
				}
				if {{ .IterLabel }} == {{ MaxLen .MaxLen "Array" }} - 1 {
					return fmt.Errorf("{{ .Name }}: slice too large")
				}
			}
		}
		{{ if .PreserveNil }}
		}
		{{ end }}
	}`); err != nil {
		return err
	}

	return nil
}

func (g Gen) emitDagJsonUnmarshalArrayField(w io.Writer, f Field) error {
	if f.IterLabel == "" {
		f.IterLabel = "i"
	}

	e := f.Type.Elem()
	var pointer bool
	if e.Kind() == reflect.Ptr {
		pointer = true
		e = e.Elem()
	}

	if e.Kind() == reflect.Uint8 {
		return g.doTemplate(w, f, `
		{
			bval, err := jr.ReadBytes({{ MaxLen .MaxLen "Bytes" }})
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			{{ .Name }} = {{ .TypeName }}(bval)
		}`)
	}

	err := g.doTemplate(w, f, `
	if err := jr.ReadArrayOpen(); err != nil {
		return fmt.Errorf("{{ .Name }}: %w", err)
	}

	{{ .Name }} = {{ .TypeName }}{}
	for {{ .IterLabel }} := 0; {{ .IterLabel }} < {{ MaxLen .MaxLen "Array" }}; {{ .IterLabel }}++ {`)
	if err != nil {
		return err
	}

	switch e.Kind() {
	case reflect.Struct:
		subf := Field{
			Type:    e,
			Pkg:     f.Pkg,
			Pointer: pointer,
			Name:    f.Name + "[" + f.IterLabel + "]",
		}
		err := g.emitDagJsonUnmarshalStructField(w, subf)
		if err != nil {
			return err
		}
	case reflect.Uint64:
		subf := Field{
			Type: e,
			Pkg:  f.Pkg,
			Name: f.Name + "[" + f.IterLabel + "]",
		}
		err := g.emitDagJsonUnmarshalUint64Field(w, subf)
		if err != nil {
			return err
		}
	case reflect.Int64:
		subf := Field{
			Type: e,
			Pkg:  f.Pkg,
			Name: f.Name + "[" + f.IterLabel + "]",
		}
		err := g.emitDagJsonUnmarshalInt64Field(w, subf)
		if err != nil {
			return err
		}
	case reflect.Array:
		nextIter := string([]byte{f.IterLabel[0] + 1})
		subf := Field{
			Name:      fmt.Sprintf("%s[%s]", f.Name, f.IterLabel),
			Type:      e,
			IterLabel: nextIter,
			Pkg:       f.Pkg,
		}
		if err := g.emitDagJsonUnmarshalArrayField(w, subf); err != nil {
			return err
		}
	case reflect.Slice:
		nextIter := string([]byte{f.IterLabel[0] + 1})
		subf := Field{
			Name:      fmt.Sprintf("%s[%s]", f.Name, f.IterLabel),
			Type:      e,
			IterLabel: nextIter,
			Pkg:       f.Pkg,
		}
		if err := g.emitDagJsonUnmarshalSliceField(w, subf); err != nil {
			return err
		}

	case reflect.String:
		subf := Field{
			Type: e,
			Pkg:  f.Pkg,
			Name: f.Name + "[" + f.IterLabel + "]",
		}
		err := g.emitDagJsonUnmarshalStringField(w, subf)
		if err != nil {
			return err
		}

	default:
		return fmt.Errorf("do not yet support slices of %s yet", e.Elem())
	}

	if err := g.doTemplate(w, f, `
		close, err := jr.ReadArrayCloseOrComma()
		if err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		if close {
			break
		}
		if {{ .IterLabel }} == {{ MaxLen .MaxLen "Array" }} - 1 {
			return fmt.Errorf("{{ .Name }}: array too large")
		}
	}`); err != nil {
		return err
	}

	return nil
}

func (g Gen) emitDagJsonUnmarshalStructTuple(w io.Writer, gti *GenTypeInfo) (err error) {
	if gti.Transparent {
		err = g.doTemplate(w, gti, `
		func (t *{{ .Name }}) UnmarshalDagJSON(r io.Reader) (err error) {
			*t = {{ .Name }}{}

			jr := jsg.NewDagJsonReader(r)`)
	} else {
		err = g.doTemplate(w, gti, `
		func (t *{{ .Name }}) UnmarshalDagJSON(r io.Reader) (err error) {
			*t = {{ .Name }}{}

			jr := jsg.NewDagJsonReader(r)
			defer func() {
				if err == io.EOF {
					err = io.ErrUnexpectedEOF
				}
			}()
			if err := jr.ReadArrayOpen(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			close, err := jr.PeekArrayClose()
			if err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
			if close {
				if err := jr.ReadArrayClose(); err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
			} else {`)
	}
	if err != nil {
		return err
	}

	for fieldIndex, f := range gti.Fields {
		if f.Name == FieldNameSelf {
			f.Name = "(*t)" // self
		} else {
			f.Name = "t." + f.Name
		}

		fmt.Fprintf(w, "\n\n\t// %s (%s) (%s)\n", f.Name, f.Type, f.Type.Kind())

		switch f.Type.Kind() {
		case reflect.String:
			if err := g.emitDagJsonUnmarshalStringField(w, f); err != nil {
				return err
			}
		case reflect.Struct:
			if err := g.emitDagJsonUnmarshalStructField(w, f); err != nil {
				return err
			}
		case reflect.Uint64:
			if err := g.emitDagJsonUnmarshalUint64Field(w, f); err != nil {
				return err
			}
		case reflect.Uint8:
			if err := g.emitDagJsonUnmarshalUint8Field(w, f); err != nil {
				return err
			}
		case reflect.Int64:
			if err := g.emitDagJsonUnmarshalInt64Field(w, f); err != nil {
				return err
			}
		case reflect.Array:
			if err := g.emitDagJsonUnmarshalArrayField(w, f); err != nil {
				return err
			}
		case reflect.Slice:
			if err := g.emitDagJsonUnmarshalSliceField(w, f); err != nil {
				return err
			}
		case reflect.Bool:
			if err := g.emitDagJsonUnmarshalBoolField(w, f); err != nil {
				return err
			}
		case reflect.Map:
			if err := g.emitDagJsonUnmarshalMapField(w, f); err != nil {
				return err
			}
		default:
			return fmt.Errorf("field %q of %q has unsupported kind %q", f.Name, gti.Name, f.Type.Kind())
		}
		if !gti.Transparent {
			if fieldIndex < gti.MandatoryFieldCount-1 {
				if err := g.doTemplate(w, gti, `
				{
					close, err := jr.ReadArrayCloseOrComma()
					if err != nil {
						return fmt.Errorf("{{ .Name }}: %w", err)
					}`); err != nil {
					return err
				}
				if _, err := fmt.Fprintf(w, `
					if close {
						return fmt.Errorf("json input has too few fields %d < %d")
					}
				}`, fieldIndex+1, gti.MandatoryFieldCount); err != nil {
					return err
				}
			} else if fieldIndex == len(gti.Fields)-1 {
				if err := g.doTemplate(w, gti, `
				if err := jr.ReadArrayClose(); err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}`); err != nil {
					return err
				}
			} else {
				if err := g.doTemplate(w, gti, `
				{
					close, err := jr.ReadArrayCloseOrComma()
					if err != nil {
						return fmt.Errorf("{{ .Name }}: %w", err)
					}
					if close {
						return nil
					}
				}`); err != nil {
					return err
				}
			}
		}
	}

	if !gti.Transparent {
		if _, err := fmt.Fprintf(w, "\n}"); err != nil {
			return err
		}
	}

	_, err = fmt.Fprintf(w, "\n\treturn nil\n}\n\n")
	return err
}

// GenTupleEncodersForType is a convenience wrapper around Gen.GenTupleEncodersForType using
// default options.
func GenTupleEncodersForType(gti *GenTypeInfo, w io.Writer) error {
	return Gen{}.GenTupleEncodersForType(gti, w)
}

// Generates 'tuple representation' dag json encoders for the given type
func (g Gen) GenTupleEncodersForType(gti *GenTypeInfo, w io.Writer) error {
	if err := g.emitDagJsonMarshalStructTuple(w, gti); err != nil {
		return err
	}

	if err := g.emitDagJsonUnmarshalStructTuple(w, gti); err != nil {
		return err
	}

	return nil
}

func emptyValForField(f Field) (string, error) {
	if f.Pointer {
		return "nil", nil
	} else {
		switch f.Type.Kind() {
		case reflect.String:
			return "\"\"", nil
		case reflect.Slice:
			return "nil", nil
		default:
			return "", fmt.Errorf("omit empty not supported for %s", f.Type.Kind())
		}
	}
}

func (g Gen) emitDagJsonMarshalStructMap(w io.Writer, gti *GenTypeInfo) error {
	if gti.Transparent {
		return fmt.Errorf("%#v: transparent fields not supported in map mode, use tuple encoding (outcome should be the same)", gti.Name)
	}

	err := g.doTemplate(w, gti, `
	func (t *{{ .Name }}) MarshalDagJSON(w io.Writer) error {
		jw := jsg.NewDagJsonWriter(w)
		if t == nil {
			err := jw.WriteNull()
			return err
		}`)
	if err != nil {
		return err
	}

	if _, err := fmt.Fprintf(w, `
	if err := jw.WriteObjectOpen(); err != nil {
		return err
	}`); err != nil {
		return err
	}

	sort.Slice(gti.Fields, func(i, j int) bool {
		fi := gti.Fields[i]
		fj := gti.Fields[j]

		if len(fi.MapKey) < len(fj.MapKey) {
			return true
		}
		if len(fi.MapKey) > len(fj.MapKey) {
			return false
		}

		// TODO: is this properly canonical?
		return fi.MapKey < fj.MapKey
	})

	if len(gti.Fields) > 1 {
		if _, err := fmt.Fprintf(w, "\nwritten := 0"); err != nil {
			return err
		}
	}

	for i, f := range gti.Fields {
		if i > 0 {
			if f.OmitEmpty {
				// write the comma if the current field is omitempty and not empty
				if err := g.doTemplate(w, f, `
				if t.{{.Name}} != {{ .EmptyVal }} {`); err != nil {
					return err
				}
			}
			// write a comma so long as there was a previous field that was written
			if _, err := fmt.Fprintf(w, `
			if written > 0 {
				if err := jw.WriteComma(); err != nil {
					return err
				}
			}`); err != nil {
				return err
			}
			if f.OmitEmpty {
				if _, err := fmt.Fprintf(w, "\n}"); err != nil {
					return err
				}
			}
		}

		fmt.Fprintf(w, "\n\n\t// t.%s (%s) (%s)", f.Name, f.Type, f.Type.Kind())

		if f.OmitEmpty {
			if err := g.doTemplate(w, f, "\nif t.{{.Name}} != {{ .EmptyVal }} {"); err != nil {
				return err
			}
		}

		if err := g.emitDagJsonMarshalStringField(w, Field{
			Name: `"` + f.MapKey + `"`,
		}); err != nil {
			return err
		}

		if _, err := fmt.Fprintf(w, `
		if err := jw.WriteObjectColon(); err != nil {
			return err
		}`); err != nil {
			return err
		}

		f.Name = "t." + f.Name
		switch f.Type.Kind() {
		case reflect.String:
			if err := g.emitDagJsonMarshalStringField(w, f); err != nil {
				return err
			}
		case reflect.Struct:
			if err := g.emitDagJsonMarshalStructField(w, f); err != nil {
				return err
			}
		case reflect.Uint64:
			if err := g.emitDagJsonMarshalUint64Field(w, f); err != nil {
				return err
			}
		case reflect.Int64:
			if err := g.emitDagJsonMarshalInt64Field(w, f); err != nil {
				return err
			}
		case reflect.Uint8:
			if err := g.emitDagJsonMarshalUint8Field(w, f); err != nil {
				return err
			}
		case reflect.Array:
			if err := g.emitDagJsonMarshalArrayField(w, f); err != nil {
				return err
			}
		case reflect.Slice:
			if err := g.emitDagJsonMarshalSliceField(w, f); err != nil {
				return err
			}
		case reflect.Bool:
			if err := g.emitDagJsonMarshalBoolField(w, f); err != nil {
				return err
			}
		case reflect.Map:
			if err := g.emitDagJsonMarshalMapField(w, f); err != nil {
				return err
			}
		default:
			return fmt.Errorf("field %q of %q has unsupported kind %q", f.Name, gti.Name, f.Type.Kind())
		}

		if len(gti.Fields) > 1 {
			if err := g.doTemplate(w, f, `
			written++`); err != nil {
				return err
			}
		}

		if f.OmitEmpty {
			if err := g.doTemplate(w, f, "\n}"); err != nil {
				return err
			}
		}
	}

	_, err = fmt.Fprintf(w, `
			if err := jw.WriteObjectClose(); err != nil {
				return err
			}
		return nil
	}`)
	return err
}

func (g Gen) emitDagJsonUnmarshalStructMap(w io.Writer, gti *GenTypeInfo) error {
	err := g.doTemplate(w, gti, `
	func (t *{{ .Name }}) UnmarshalDagJSON(r io.Reader) (err error) {
		*t = {{ .Name }}{}

		jr := jsg.NewDagJsonReader(r)
		defer func() {
			if err == io.EOF {
				err = io.ErrUnexpectedEOF
			}
		}()
		if err := jr.ReadObjectOpen(); err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		close, err := jr.PeekObjectClose()
		if err != nil {
			return fmt.Errorf("{{ .Name }}: %w", err)
		}
		if close {
			if err := jr.ReadObjectClose(); err != nil {
				return fmt.Errorf("{{ .Name }}: %w", err)
			}
		} else {
			for i := uint64(0); i < {{ MaxLen 0 "Array" }}; i++ {
				name, err := jr.ReadString({{ MaxLen 0 "String" }})
				if err != nil {
					if errors.Is(err, jsg.ErrLimitExceeded) {
						return fmt.Errorf("{{ .Name }}: string too large")
					}
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
				if err := jr.ReadObjectColon(); err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}`)
	if err != nil {
		return err
	}

	err = g.doTemplate(w, gti, `
	switch name {`)
	if err != nil {
		return err
	}

	for _, f := range gti.Fields {
		fmt.Fprintf(w, "\n\n// t.%s (%s) (%s)", f.Name, f.Type, f.Type.Kind())

		err := g.doTemplate(w, f, `
		case "{{ .MapKey }}":`)
		if err != nil {
			return err
		}

		f.Name = "t." + f.Name

		switch f.Type.Kind() {
		case reflect.String:
			if err := g.emitDagJsonUnmarshalStringField(w, f); err != nil {
				return err
			}
		case reflect.Struct:
			if err := g.emitDagJsonUnmarshalStructField(w, f); err != nil {
				return err
			}
		case reflect.Uint64:
			if err := g.emitDagJsonUnmarshalUint64Field(w, f); err != nil {
				return err
			}
		case reflect.Int64:
			if err := g.emitDagJsonUnmarshalInt64Field(w, f); err != nil {
				return err
			}
		case reflect.Uint8:
			if err := g.emitDagJsonUnmarshalUint8Field(w, f); err != nil {
				return err
			}
		case reflect.Array:
			if err := g.emitDagJsonUnmarshalArrayField(w, f); err != nil {
				return err
			}
		case reflect.Slice:
			if err := g.emitDagJsonUnmarshalSliceField(w, f); err != nil {
				return err
			}
		case reflect.Bool:
			if err := g.emitDagJsonUnmarshalBoolField(w, f); err != nil {
				return err
			}
		case reflect.Map:
			if err := g.emitDagJsonUnmarshalMapField(w, f); err != nil {
				return err
			}
		default:
			return fmt.Errorf("field %q of %q has unsupported kind %q", f.Name, gti.Name, f.Type.Kind())
		}
	}

	return g.doTemplate(w, gti, `
				default:
					// Field doesn't exist on this type, so ignore it
					if err := jr.DiscardType(); err != nil {
						return fmt.Errorf("{{ .Name }}: ignoring field %s: %w", name, err)
					}
				}

				close, err := jr.ReadObjectCloseOrComma()
				if err != nil {
					return fmt.Errorf("{{ .Name }}: %w", err)
				}
				if close {
					break
				}
				if i == {{ MaxLen 0 "Array" }} - 1 {
					return fmt.Errorf("{{ .Name }}: map too large")
				}
			}
		}

		return nil
	}`)
}

// GenMapEncodersForType is a convenience wrapper around Gen.GenMapEncodersForType using default
// options.
func GenMapEncodersForType(gti *GenTypeInfo, w io.Writer) error {
	return Gen{}.GenMapEncodersForType(gti, w)
}

// Generates 'map representation' dag json encoders for the given type
func (g Gen) GenMapEncodersForType(gti *GenTypeInfo, w io.Writer) error {
	if err := g.emitDagJsonMarshalStructMap(w, gti); err != nil {
		return err
	}

	if err := g.emitDagJsonUnmarshalStructMap(w, gti); err != nil {
		return err
	}

	return nil
}
